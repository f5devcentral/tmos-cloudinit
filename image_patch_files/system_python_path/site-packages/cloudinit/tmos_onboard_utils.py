# coding=utf-8
# pylint: disable=broad-except
# Copyright (c) 2016-2018, F5 Networks, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
This module supplies general onboarding utility functions
"""
import json
import logging
import os
import stat
import re
import socket
import subprocess
import urlparse
import time
import requests

from cloudinit import util
from cloudinit import ssh_util

LOG_FILE = '/var/log/f5-cloudinit.log'

MGMT_DHCP_TIMEOUT = 600
MCPD_TIMEOUT = 600
PROCESS_KILL_DELAY = 2
BIGSTART_DELAY = 5
ICONTROL_TIMEOUT = 600
ICONTROLLX_TIMEOUT = 600
ICONTROLLX_PACKAGE_INSTALL_DELAY = 5
URL_TIMEOUT = 600

OUT_DIR = '/var/lib/cloud/'

MGMT_DHCP_LEASE_FILE = '/var/lib/dhclient/dhclient.leases'

DO_DECLARATION_DIR = OUT_DIR + 'f5-declarative-onboarding'
TS_DECLARATION_DIR = OUT_DIR + 'f5-telemetry-streaming'
AS3_DECLARATION_DIR = OUT_DIR + 'f5-appsvcs-extension'

DHCP_LEASE_DIR = OUT_DIR + '/dhclient'

# PKG_INSTALL_DIR = '/shared/rpms/icontrollx_installs'
PKG_INSTALL_DIR = OUT_DIR + 'icontrollx_installs'

DO_DECLARATION_FILE = DO_DECLARATION_DIR + '/do_declaration.json'
TS_DECLARATION_FILE = TS_DECLARATION_DIR + '/ts_declaration.json'
AS3_DECLARATION_FILE = AS3_DECLARATION_DIR + '/as3_declaration.json'

RPM_INSTALL_PROGRESS_FLAG_FILE_PREFIX = OUT_DIR + 'ICONTROL_LX_INSTALL_'

SSH_KEY_FILE = '/root/.ssh/authorized_keys'
DEFAULT_DNS_SERVERS = ['8.8.8.8', '8.8.4.4']
DEFAULT_NTP_SERVERS = ['0.pool.ntp.org', '1.pool.ntp.org']
DEFAULT_TIMEZONE = 'UTC'
DEFAULT_CONFIGSYNC_INTERFACE = '1.1'

REMOVE_DHCP_LEASE_FILES = False


def touch_file(logfile, times=None):
    """Touch file if needed"""
    if not os.path.isfile(logfile):
        if not os.path.exists(os.path.dirname(logfile)):
            os.makedirs(os.path.dirname(logfile))
        with open(logfile, 'a'):
            os.utime(logfile, times)


touch_file(LOG_FILE)

LOG = logging.getLogger(__name__)
LOG.setLevel(logging.DEBUG)
FORMATTER = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
LOGFILE = logging.FileHandler(LOG_FILE)
LOGFILE.setLevel(logging.DEBUG)
LOGFILE.setFormatter(FORMATTER)
LOG.addHandler(LOGFILE)

# inject discovered SSH keys, we don't use the ssh_keys cloud-init module
# because it uses SELinuxGuard, which we don't know will always be
# safe with TMOS versions


def inject_public_ssh_keys(keys):
    """Injects discovered and metadata supplied SSH keys into the root account"""
    keys_to_add = {}
    parser = ssh_util.AuthKeyLineParser()
    for k in keys:
        authkeyline = parser.parse(str(k))
        keys_to_add[authkeyline.base64] = k
    existing_keys = ssh_util.parse_authorized_keys(SSH_KEY_FILE)
    for existing_key in existing_keys:
        if existing_key.base64 in keys_to_add:
            del keys_to_add[existing_key.base64]
    with open(SSH_KEY_FILE, 'a+') as keyfile:
        for k in keys_to_add:
            keyfile.write(keys_to_add[k] + '\n')


def is_v6(address):
    """Determines if the supplied address is a valid IPv6 address"""
    try:
        socket.inet_pton(socket.AF_INET6, address)
        return True
    except socket.error:
        return False


def is_v4(address):
    """Determines if the supplied address is a valid IPv4 address"""
    try:
        socket.inet_pton(socket.AF_INET, address)
        return True
    except socket.error:
        return False


def is_mgmt_ip():
    """Test if the mgmt interface has an IP address assigned"""
    fnull = open(os.devnull, 'w')
    mgmt_ip = subprocess.Popen(
        "ip addr show mgmt | grep '^\\s*inet '| grep -v 169.254 | wc -l",
        stdout=subprocess.PIPE,
        stderr=fnull,
        shell=True).communicate()[0].replace('\n', '')
    if int(mgmt_ip) == 1:
        return True
    mgmt_ip = subprocess.Popen(
        "ip addr show mgmt | grep '^\\s*inet6 '| grep -v fe80 | wc -l",
        stdout=subprocess.PIPE,
        shell=True).communicate()[0].replace('\n', '')
    if int(mgmt_ip) == 1:
        return True
    return False


def get_mgmt_cidr():
    """Return the managment interface IP address in CIDR notation from tmsh"""
    fnull = open(os.devnull, 'w')
    mgmt_cidr = subprocess.Popen(
        "tmsh list sys management-ip one-line | cut -d' ' -f3",
        stdout=subprocess.PIPE,
        stderr=fnull,
        shell=True).communicate()[0].replace('\n', '')
    return mgmt_cidr


def is_mgmt_default_gateway():
    """Test if the mgmt subnet has a default gateway"""
    fnull = open(os.devnull, 'w')
    mgmt_gw = subprocess.Popen("route -n | grep '^0.0.0.0'| grep mgmt | wc -l",
                               stdout=subprocess.PIPE,
                               stderr=fnull,
                               shell=True).communicate()[0].replace('\n', '')
    if int(mgmt_gw) == 1:
        return True
    return False


def get_tmos_version():
    """Get the TMOS version string"""
    fnull = open(os.devnull, 'w')
    version = subprocess.Popen(
        "cat /VERSION | grep -i sequence | cut -d':' -f2 | tr '[A-Z]' '[a-z]' | tr -d '[:space:]'",
        stdout=subprocess.PIPE,
        stderr=fnull,
        shell=True).communicate()[0].replace('\n', '')
    return version


def get_tmos_product():
    """Get the TMOS product string"""
    fnull = open(os.devnull, 'w')
    product = subprocess.Popen(
        "tmsh show sys version | grep Product | awk '{print $NF}'",
        stdout=subprocess.PIPE,
        stderr=fnull,
        shell=True).communicate()[0].replace('\n', '')
    return product


def get_dmi_uuid():
    """Get the system UUID from DMI"""
    fnull = open(os.devnull, 'w')
    uuid = subprocess.Popen(
        "dmidecode | grep -i UUID | cut -d':' -f2 | tr '[A-Z]' '[a-z]' | tr -d '[:space:]'",
        stdout=subprocess.PIPE,
        stderr=fnull,
        shell=True).communicate()[0].replace('\n', '')
    return uuid


def get_hostname():
    """Get the system hostname"""
    return socket.gethostname()


def run_cmd(cmd):
    """Run a CLI command and return its output"""
    fnull = open(os.devnull, 'w')
    cmd_stdout = subprocess.Popen(cmd,
                                  stdout=subprocess.PIPE,
                                  stderr=fnull,
                                  shell=True).communicate()[0].replace(
                                      '\n', '')
    LOG.debug('running command %s produced %s', cmd, cmd_stdout)
    return cmd_stdout


def wait_for_mgmt_dhcp(timeout=None):
    """Blocks until the mgmt DHCP lease file is present"""
    if not timeout:
        timeout = MGMT_DHCP_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if os.path.isfile(MGMT_DHCP_LEASE_FILE):
            return True
        time.sleep(1)
    return False


def is_mcpd():
    """Determines if the TMOS master control process is running"""
    fnull = open(os.devnull, 'w')
    running = subprocess.Popen(
        "tmsh -a show sys mcp-state field-fmt | grep running | wc -l",
        stdout=subprocess.PIPE,
        stderr=fnull,
        shell=True).communicate()[0].replace('\n', '')
    if int(running) == 1:
        return True
    return False


def wait_for_mcpd(timeout=None):
    """Blocks until the TMOS master control process is running"""
    if not timeout:
        timeout = MCPD_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if is_mcpd():
            return True
        time.sleep(1)
    LOG.error('mcpd did not reach tunning state in %s seconds', timeout)
    return False


def is_tmm():
    """Determines if the TMOS dataplane microkernels are running"""
    tmm_running = int(
        subprocess.Popen(
            "ps -ef|grep /usr/bin/tmm|grep -v grep|wc -l| tr -d ';\n'",
            stdout=subprocess.PIPE,
            shell=True).communicate()[0])
    if tmm_running == 1:
        return True
    return False


def force_tmm_down():
    """Forces all TMOS dataplane microkernels down"""
    fnull = open(os.devnull, 'w')
    subprocess.call(['/bin/pkill', 'tmm'], stdout=fnull, stderr=fnull)
    subprocess.call(['/bin/bigstart', 'shutdown', 'tmm'],
                    stdout=fnull,
                    stderr=fnull)
    subprocess.call(['/bin/pkill', 'tmm'], stdout=fnull, stderr=fnull)
    time.sleep(PROCESS_KILL_DELAY)


def stop_tmm():
    """Stops TMOS dataplane microkernels"""
    fnull = open(os.devnull, 'w')
    subprocess.call(['/bin/bigstart', 'shutdown', 'tmm'],
                    stdout=fnull,
                    stderr=fnull)
    time.sleep(BIGSTART_DELAY)


def start_tmm():
    """Starts TMOS dataplane microkernels"""
    fnull = open(os.devnull, 'w')
    subprocess.call(['/bin/bigstart', 'startup', 'tmm'],
                    stdout=fnull,
                    stderr=fnull)
    time.sleep(BIGSTART_DELAY)


def bigstart_restart(service_name=None):
    """Restart a service with bigstart"""
    fnull = open(os.devnull, 'w')
    if not service_name:
        service_name = ''
    subprocess.call(['/bin/bigstart', 'restart', service_name],
                    stdout=fnull,
                    stderr=fnull)
    time.sleep(BIGSTART_DELAY)


def is_icontrol():
    """Determines if the TMOS control plane iControl REST service is running"""
    try:
        return requests.get('http://localhost:8100/shared/echo',
                            auth=('admin', '')).json()['stage'] == 'STARTED'
    except Exception:
        return False


def wait_for_icontrol(timeout=None):
    """Blocks until the TMOS control plane iControl REST service is running"""
    if not timeout:
        timeout = ICONTROL_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if is_icontrol():
            return True
        time.sleep(1)
    LOG.error('iControl REST services could not be reached after %s seconds',
              timeout)
    return False


def is_rest_worker(workerpath):
    """Determines if the TMOS control plane iControl REST worker path exists"""
    try:
        return requests.get('http://localhost:8100' + workerpath,
                            auth=('admin', '')).status_code != 404
    except Exception:
        return False


def wait_for_rest_worker(workerpath, timeout=None):
    """Blocks until the TMOS control plane iControl REST worker path exists"""
    task_url = 'http://localhost:8100' + workerpath
    if not timeout:
        timeout = ICONTROL_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        try:
            response = requests.get(task_url, auth=('admin', ''))
            if response.status_code < 400:
                return True
        except Exception:
            return False
        time.sleep(1)
    LOG.error('iControl REST worker %s could not be reached after %s seconds',
              workerpath, timeout)
    return False


def is_icontrollx():
    """Determines if the TMOS control plane iControl REST service is running"""
    try:
        response = requests.get('http://localhost:8100/mgmt/shared/echo-js',
                                auth=('admin', ''))
        if response.status_code < 400:
            return True
        return False
    except Exception:
        return False


def wait_for_icontrollx(timeout=None):
    """Blocks until the TMOS control plane iControl Node service is running"""
    if not timeout:
        timeout = ICONTROLLX_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if is_icontrollx():
            return True
        time.sleep(1)
    LOG.error('iControl LX services could not be reached after %s seconds',
              timeout)
    return False


def is_url(monitor_url, status_code=None):
    """Determins if the URL is reachable and optionally returns a status code"""
    try:
        response = requests.get(monitor_url)
        LOG.debug('URL %s status %s', monitor_url, response.status_code)
        if status_code:
            if response.status_code == status_code:
                return True
        return True
    except Exception as ex:
        LOG.error('URL %s exception %s', monitor_url, ex)
        return False
    return False


def wait_for_url(monitor_url, status_code=None, timeout=None):
    """Blocks until the URL is availale"""
    if not timeout:
        timeout = URL_TIMEOUT
    end_time = time.time() + timeout
    while (end_time - time.time()) > 0:
        if is_url(monitor_url, status_code):
            return True
        time.sleep(1)
    LOG.error('URL %s could not be reached after %s seconds', monitor_url,
              timeout)
    return False


def is_onenic():
    """Determines if the TMOS deployment is a 1NIC deployment"""
    if is_mcpd():
        fnull = open(os.devnull, 'w')
        is_1nic = subprocess.call(
            ['/usr/bin/tmsh', 'list', 'net', 'interface', '1.0'],
            stdout=fnull,
            stderr=fnull)
        if is_1nic == 0:
            return True
        return False
    else:
        interfaces = subprocess.Popen(
            "ip link | egrep 'eth[1-9]' | cut -d':' -f2 | tr -d ' '",
            stdout=subprocess.PIPE,
            shell=True).communicate()[0].split('\n')
        if 'eth1' in interfaces:
            return False
        return True


def dhcp_lease_dir_exists():
    """Ensures DHCP lease file copy directory exists"""
    if not os.path.isdir(DHCP_LEASE_DIR):
        os.makedirs(DHCP_LEASE_DIR)


def make_dhcp4_request(interface, timeout=120):
    """Makes DHCPv4 queries out a linux link device"""
    dhcp_lease_dir_exists()
    tmp_conf_file = DHCP_LEASE_DIR + '/dhclient.conf'
    lease_file = DHCP_LEASE_DIR + '/' + interface + '.lease'
    tmp_lease_file = '/tmp/' + interface + '.lease'
    fnull = open(os.devnull, 'w')
    dhclient_cf = open(tmp_conf_file, 'w')
    dhclient_cf.write(
        "\nrequest subnet-mask, broadcast-address, time-offset, routers,\n")
    dhclient_cf.write(
        "        domain-name, domain-name-servers, domain-search, host-name,\n"
    )
    dhclient_cf.write(
        "        root-path, interface-mtu, classless-static-routes;\n")
    dhclient_cf.close()
    if os.path.isfile(lease_file):
        util.del_file(lease_file)
    subprocess.call(['/bin/pkill', 'dhclient'], stdout=fnull)
    subprocess.call(['/sbin/ip', 'link', 'set', interface, 'up'], stdout=fnull)
    subprocess.call([
        '/sbin/dhclient', '-lf', tmp_lease_file, '-cf', tmp_conf_file, '-1',
        '-timeout',
        str(timeout), '-pf', '/tmp/dhclient.' + interface + '.pid', '-sf',
        '/bin/echo', interface
    ],
                    stdout=fnull)
    if os.path.getsize(tmp_lease_file) > 0:
        util.copy(tmp_lease_file, lease_file)
        subprocess.call(['/bin/pkill', 'dhclient'], stdout=fnull)
        util.del_file('/tmp/dhclient.' + interface + '.pid')
        util.del_file(tmp_lease_file)
        return True
    else:
        subprocess.call(['/bin/pkill', 'dhclient'], stdout=fnull)
        util.del_file('/tmp/dhclient.' + interface + '.pid')
        util.del_file(tmp_lease_file)
    return False


def process_dhcp4_lease(interface, return_options=None):
    """Parses dhclient v4 lease file format for metadata"""
    if not return_options:
        return_options = [
            'subnet-mask', 'routers', 'domain-name-servers', 'interface-mtu',
            'classless-static-routes', 'host-name', 'domain-name'
        ]
    return_data = {}

    lease_file = DHCP_LEASE_DIR + '/' + interface + '.lease'
    if os.path.isfile(interface):
        lease_file = interface

    for line in open(lease_file):
        if 'fixed-address' not in return_data and "fixed-address" in line:
            # format: fixed-address 1.1.1.110;
            test_fixed_address = 'fixed-address '
            lidx = line.index(test_fixed_address)
            return_data['fixed-address'] = \
                line[lidx + len(test_fixed_address):].replace(';\n', '')
        for option in return_options:
            test_option = option + ' '
            if (option not in return_data) and (test_option in line):
                # format: option routers 1.1.1.1;
                lidx = line.index(test_option)
                return_data[option] = \
                    line[lidx + len(test_option):].replace(
                        ';\n', '').replace('"', '').replace("'", '')
    return return_data


def process_dhcp4_routes(static_routes):
    """Processes dhclient v4 static routes metadata"""
    dhcp_routes = []
    if static_routes:
        static_route_list = static_routes.split(',')
        for static_route in static_route_list:
            rap = static_route.split(' ')
            route = process_dhcp4_route(rap[0], rap[1])
            if route:
                dhcp_routes.append(route)
    return dhcp_routes


def process_dhcp4_route(static_route, gateway):
    """Parse single dhclient v4 route entry into a dictionary"""
    if not static_route == '0':
        route = {}
        route['network'] = static_route[static_route.find('.') + 1:]
        if len(route['network']) == 3:
            route['network'] = route['network'] + '.0.0.0'
        if route['network'].find('.') > 0:
            dots = route['network'].count('.')
            if dots == 1:
                route['network'] = route['network'] + '.0.0'
            if dots == 2:
                route['network'] = route['network'] + '.0'
        route['netmask'] = static_route[0:static_route.find('.')]
        route['gateway'] = gateway
        route['route_name'] = "route_%s_%s" % (route['network'],
                                               route['netmask'])
        route['route_name'] = route['route_name'].replace('.', '_').replace(
            ':', '_').replace('/', '_')
        # we don't forward to local or link local in a gateway
        if route['network'].startswith('127'):
            return None
        elif route['network'].startswith('169.254'):
            return None
        elif route['network'].lower().startswith('fe80'):
            return None
        return route
    return None


def ipv4_cidr_from_netmask(netmask):
    """Convert IPv4 netmask to CIDR bits"""
    return sum([bin(int(x)).count('1') for x in netmask.split('.')])


def do_declaration_dir_exists():
    """Ensures f5-declarative-onboarding declaration copy directory exists"""
    if not os.path.isdir(DO_DECLARATION_DIR):
        os.makedirs(DO_DECLARATION_DIR)


def persist_do_declaration(declaration=None, additional_declarations=None):
    """Write the f5-declarative-onboarding declaration to file"""
    do_declaration_dir_exists()
    # file injected DO declaration (user-data trumps file injected)
    if os.path.isfile(DO_DECLARATION_FILE):
        if not additional_declarations:
            LOG.info(
                'found file injected f5-declarative-onboarding declarations')
            with open(DO_DECLARATION_FILE, 'r') as ad:
                additional_declarations = json.load(ad)
        else:
            LOG.info(
                'using f5-declarative-onboarding user-data or downloaded declarations instead of file injected declarations'
            )
        util.del_file(DO_DECLARATION_FILE)
    # created DO declaration from IaaS resolved resources merged with additionals
    if declaration and additional_declarations:
        LOG.info(
            'additional f5-declarative-onboarding declaration items overwriting IaaS resolved declarations'
        )
        for key, value in additional_declarations['Common'].iteritems():
            declaration['Common'][key] = value
    elif additional_declarations:
        LOG.info(
            'no IaaS resolved f5-declarative-onboarding declarations, using user supplied declarations only'
        )
        declaration = additional_declarations
    LOG.info('writing out f5-declarative-onboarding declaration file %s',
             DO_DECLARATION_FILE)
    try:
        util.write_file(DO_DECLARATION_FILE, json.dumps(declaration))
    except Exception as ex:
        LOG.error(
            'error writing out f5-declarative-onboarding declaration file %s: %s',
            DO_DECLARATION_DIR, ex)


def persist_do_declaration_from_url(declaration=None,
                                    additional_declaration_url=None):
    """Write the f5-declarative-onboarding declaration to file with additions from URL"""
    additional_declarations = None
    if additional_declaration_url:
        LOG.info('downloading f5-declarative-onboarding declaration from %s',
                 additional_declaration_url)
        if download_file(additional_declaration_url, DO_DECLARATION_DIR,
                         'additional_declarations'):
            try:
                df = "%s/additional_declarations" % DO_DECLARATION_DIR
                with open(df, 'r') as ad:
                    additional_declarations = json.load(ad)
                util.del_file(df)
            except Exception as ex:
                LOG.error(
                    'f5-declarative-onboarding download declaration %s is not valid JSON or YAML: %s',
                    additional_declaration_url, ex)
                additional_declarations = None
    persist_do_declaration(declaration, additional_declarations)


def do_declare():
    """Makes a f5-declarative-onboarding declaration from the generated file"""
    if is_rest_worker('/mgmt/shared/declarative-onboarding') and \
            os.path.isfile(DO_DECLARATION_FILE):
        dec_file = open(DO_DECLARATION_FILE, 'r')
        declaration = dec_file.read()
        dec_file.close()
        json.loads(declaration)
        dec_url = 'http://localhost:8100/mgmt/shared/declarative-onboarding'
        LOG.debug('POST f5-declarative-onboarding declaration')
        response = requests.post(dec_url, auth=('admin', ''), data=declaration)
        # initial request
        if response.status_code < 400:
            LOG.info('f5-declarative-onboarding declared successfully')
            return True
        LOG.error('f5-declarative-onboarding declaration returned %s - %s',
                  response.status_code, response.text)
        return False
    LOG.error(
        'f5-declarative-onboarding worker not installed or declaration missing'
    )
    return False


def get_do_declaration():
    """Gets the current f5-declarative-onboarding declaration"""
    return requests.get(
        'http://localhost:8100/mgmt/shared/declarative-onboarding',
        auth=('admin', ''))


def get_do_status_codes():
    """Gets the current f5-declarative-onboarding declaration"""
    return requests.get(
        'http://localhost:8100/mgmt/shared/declarative-onboarding?statusCodes=experimental',
        auth=('admin', ''))


def as3_declaration_dir_exists():
    """Ensures f5-appsvcs-extension declaration copy directory exists"""
    if not os.path.isdir(AS3_DECLARATION_DIR):
        os.makedirs(AS3_DECLARATION_DIR)


def persist_as3_declaration(declaration=None):
    """Write the f5-appsvcs-extension declaration to file"""
    if declaration:
        as3_declaration_dir_exists()
        if os.path.isfile(AS3_DECLARATION_FILE):
            LOG.warning(
                'Overwriting existing f5-appsvcs-extension with user supplied declaration'
            )
            util.del_file(AS3_DECLARATION_FILE)
        util.write_file(AS3_DECLARATION_FILE, json.dumps(declaration))
    else:
        LOG.warning(
            'Request to persist f5-appsvcs-extension declaration when no declaration supplied'
        )


def download_as3_declaration(declaration_url=None):
    """Write the f5-appsvcs-extension declaration from URL"""
    if declaration_url:
        as3_declaration_dir_exists()
        if os.path.isfile(AS3_DECLARATION_FILE):
            util.del_file(AS3_DECLARATION_FILE)
        LOG.info('downloading f5-appsvcs-extension declaration from %s',
                 declaration_url)
        download_file(declaration_url, AS3_DECLARATION_DIR,
                      AS3_DECLARATION_FILE)


def as3_declaration_persisted():
    """Is there a persisted f5-appsvcs-extension declaration to declare"""
    return os.path.isfile(AS3_DECLARATION_FILE)


def as3_declare():
    """Makes an f5-appsvcs-extension declaration from the supplied metadata"""
    if is_rest_worker('/mgmt/shared/appsvcs/declare') and os.path.isfile(
            AS3_DECLARATION_FILE):
        as3df = open(AS3_DECLARATION_FILE, 'r')
        declaration = as3df.read()
        as3df.close()
        json.loads(declaration)
        d_url = 'http://localhost:8100/mgmt/shared/appsvcs/declare'
        LOG.debug('POST f5-appsvcs-extension declaration')
        response = requests.post(d_url, auth=('admin', ''), data=declaration)
        # initial request
        if response.status_code < 400:
            return True
        LOG.error('f5-appsvcs-extension declaration failed %s - %s',
                  response.status_code, response.text)
        return False
    LOG.error(
        'f5-appsvcs-extension worker not installed or declaration missing')
    return False


def get_as3_declaration():
    """Gets the existing f5-appsvcs-extension declaration"""
    return requests.get('http://localhost:8100/mgmt/shared/appsvcs/declare',
                        auth=('admin', ''))


def ts_declaration_dir_exists():
    """Ensures f5-telemetry-streaming declaration copy directory exists"""
    if not os.path.isdir(TS_DECLARATION_DIR):
        os.makedirs(TS_DECLARATION_DIR)


def persist_ts_declaration(declaration=None):
    """Write the f5-telemetry-streaming declaration to file"""
    if declaration:
        ts_declaration_dir_exists()
        if os.path.isfile(TS_DECLARATION_FILE):
            LOG.warning(
                'Overwriting existing f5-telemetry-streaming with user supplied declaration'
            )
            util.del_file(TS_DECLARATION_FILE)
        util.write_file(TS_DECLARATION_FILE, json.dumps(declaration))
    else:
        LOG.warning(
            'Request to persist f5-telemetry-streaming declaration when no declaration supplied'
        )


def download_ts_declaration(declaration_url=None):
    """Write the f5-telemetry-streaming declaration from URL"""
    if declaration_url:
        ts_declaration_dir_exists()
        if os.path.isfile(TS_DECLARATION_FILE):
            util.del_file(TS_DECLARATION_FILE)
        LOG.info('downloading f5-telemetry-streaming declaration from %s',
                 declaration_url)
        download_file(declaration_url, TS_DECLARATION_DIR, TS_DECLARATION_FILE)


def ts_declaration_persisted():
    """Is there a persisted f5-telemetry-streaming declaration to declare"""
    return os.path.isfile(TS_DECLARATION_FILE)


def ts_declare():
    """Makes an f5-telemetry-streaming declaration from the supplied metadata"""
    if is_rest_worker('/mgmt/shared/telemetry/declare') and os.path.isfile(
            TS_DECLARATION_FILE):
        tsdf = open(TS_DECLARATION_FILE, 'r')
        declaration = tsdf.read()
        tsdf.close()
        json.loads(declaration)
        d_url = 'http://localhost:8100/mgmt/shared/telemetry/declare'
        LOG.debug('POST f5-telemetry-streaming declaration')
        response = requests.post(d_url, auth=('admin', ''), data=declaration)
        # initial request
        if response.status_code < 400:
            return True
        LOG.error('f5-telemetry-streaming declaration failed %s - %s',
                  response.status_code, response.text)
        return False
    LOG.error(
        'f5-telemetry-streaming worker not installed or declaration missing')
    return False


def get_ts_declaration():
    """Gets the existing f5-telemetry-streaming declaration"""
    return requests.get('http://localhost:8100/mgmt/shared/telemetry/declare',
                        auth=('admin', ''))


def create_install_task(rpm_file_path):
    """Issues an iControl LX install task"""
    # see BZ912969 - PD hardcoded the only acceptable install path
    installer_src_path = "/var/config/rest/downloads/%s" % os.path.basename(
        rpm_file_path)
    util.copy(rpm_file_path, installer_src_path)
    install_url = 'http://localhost:8100/mgmt/shared/iapp/package-management-tasks'
    install_json = '{ "operation": "INSTALL", "packageFilePath": "%s" }' % installer_src_path
    response = requests.post(install_url,
                             auth=('admin', ''),
                             data=install_json)
    if response.status_code < 400:
        response_json = response.json()
        return response_json['id']
    return False


def create_uninstall_task(package_name):
    """Issues an iControl LX uninstall task"""
    install_url = 'http://localhost:8100/mgmt/shared/iapp/package-management-tasks'
    install_json = '{ "operation": "UNINSTALL", "packageName": "%s" }' % package_name
    response = requests.post(install_url,
                             auth=('admin', ''),
                             data=install_json)
    if response.status_code < 400:
        response_json = response.json()
        return response_json['id']
    return False


def create_query_extensions_task():
    """Issues an iControl LX query task"""
    query_url = 'http://localhost:8100/mgmt/shared/iapp/package-management-tasks'
    query_json = '{ "operation": "QUERY" }'
    response = requests.post(query_url, auth=('admin', ''), data=query_json)
    if response.status_code < 400:
        response_json = response.json()
        return response_json['id']
    return False


def get_task_status(task_id):
    """Queries the task status of an iControl LX task"""
    task_url = 'http://localhost:8100/mgmt/shared/iapp/package-management-tasks/' + task_id
    response = requests.get(task_url, auth=('admin', ''))
    if response.status_code < 400:
        response_json = response.json()
        LOG.debug('task %s returned status %s', task_id,
                  response_json['status'])
        if response_json['status'] == 'FAILED':
            if 'errorMessage' in response_json:
                LOG.error('task %s failed: %s', task_id,
                          response_json['errorMessage'])
        return response_json['status']
    return False


def query_task_until_finished(task_id):
    """Blocks until an iControl LX task finishes or fails"""
    max_attempts = 60
    while max_attempts > 0:
        max_attempts -= 1
        status = get_task_status(task_id)
        if status and status == 'FINISHED':
            return True
        elif status == 'FAILED':
            return False
        time.sleep(2)


def return_package_task(task_id):
    """Returns the content of an iControl LX task"""
    task_url = 'http://localhost:8100/mgmt/shared/iapp/package-management-tasks/' + task_id
    response = requests.get(task_url, auth=('admin', ''))
    if response.status_code < 400:
        response_json = response.json()
        if 'queryResponse' in response_json:
            return response_json['queryResponse']
        return response_json
    return False


def get_installed_extensions():
    """Queries installed iControl LX extensions"""
    task_id = create_query_extensions_task()
    query_task_until_finished(task_id)
    return return_package_task(task_id)


def uninstall_extension(package_name_prefix):
    """Uninstalls an iControl LX extension"""
    packages = get_installed_extensions()
    for package in packages:
        if package['name'].startswith(package_name_prefix):
            task_id = create_uninstall_task(package['packageName'])
            query_task_until_finished(task_id)


def wait_for_dns_resolution(fqdn, timeout=30):
    """Wait for DNS to resolve a required FQDN"""
    start = time.time()
    end = start + timeout
    while time.time() < end:
        try:
            socket.gethostbyname(fqdn)
            return True
        except socket.error:
            LOG.error('FQDN %s could not be resolved', fqdn)
            time.sleep(1)
    LOG.error('FQDN %s could not be resolved in %s seconds', fqdn, timeout)
    return False


def download_extension(extension_url):
    """Downloads an iControl LX RPM package prior to installation processing"""
    if not os.path.isdir(PKG_INSTALL_DIR):
        os.makedirs(PKG_INSTALL_DIR)
    try:
        parsed_url = urlparse.urlparse(extension_url)
        fqdn = parsed_url.netloc
        if wait_for_dns_resolution(fqdn, 120):
            destination_file = PKG_INSTALL_DIR + '/' + os.path.basename(
                extension_url)
            tmp_file = destination_file + '.part'
            if os.path.isfile(tmp_file):
                util.del_file(tmp_file)
            LOG.debug('GET %s', extension_url)
            resp = requests.get(extension_url,
                                stream=True,
                                allow_redirects=True)
            resp.raise_for_status()
            cont_disp = resp.headers.get('content-disposition')
            if cont_disp:
                cont_disp_fn = re.findall('filename=(.+)', cont_disp)
                if cont_disp_fn > 0:
                    destination_file = PKG_INSTALL_DIR + '/' + cont_disp_fn[0]
                    LOG.warning(
                        'download destination file set by disposition header to: %s',
                        destination_file)
            with open(tmp_file, 'wb') as out_file:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        out_file.write(chunk)
            if os.path.isfile(tmp_file):
                os.rename(tmp_file, destination_file)
                return True
            LOG.error('could not copy %s to %s', extension_url,
                      destination_file)
        return False
    except Exception as err:
        LOG.error("could not download: %s - %s", extension_url, err)
        return False


def validate_rpm_package(rpm_file_path):
    """Validates if the RPM integrity hash is valid and if it is signed"""
    fnull = open(os.devnull, 'w')
    rpm_check_out = subprocess.Popen("rpm -K %s" % rpm_file_path,
                                     stdout=subprocess.PIPE,
                                     stderr=fnull,
                                     shell=True).communicate()[0].replace(
                                         '\n', '')
    int_check = 'ok' in rpm_check_out.lower()
    sig_validated = False
    for validcheck in ['gpg', 'pgp']:
        if validcheck in rpm_check_out.lower():
            sig_validated = True
            break
    return (int_check, sig_validated)


def get_rpm_packager(rpm_file_path):
    """ returns the rpm package PACKAGER tag """
    fnull = open(os.devnull, 'w')
    return subprocess.Popen('rpm -qp --queryformat "%{PACKAGER}" ' +
                            rpm_file_path,
                            stdout=subprocess.PIPE,
                            stderr=fnull,
                            shell=True).communicate()[0].replace('\n', '')


def get_rpm_summary(rpm_file_path):
    """ returns the rpm package SUMMARY tag """
    fnull = open(os.devnull, 'w')
    return subprocess.Popen('rpm -qp --queryformat "%{SUMMARY}" ' +
                            rpm_file_path,
                            stdout=subprocess.PIPE,
                            stderr=fnull,
                            shell=True).communicate()[0].replace('\n', '')


def get_rpm_package_name(rpm_file_path):
    """ returns the rpm package NAME tag """
    fnull = open(os.devnull, 'w')
    return subprocess.Popen('rpm -qp --queryformat "%{NAME}" ' + rpm_file_path,
                            stdout=subprocess.PIPE,
                            stderr=fnull,
                            shell=True).communicate()[0].replace('\n', '')


def install_extensions(trusted_sources=True):
    """Install iControl LX package RPMs found in the RPM_INSTALL_DIR directory"""
    if not os.path.isdir(PKG_INSTALL_DIR):
        LOG.warn('No iControl LX extensions found to install')
        return False
    touch_file('/var/config/rest/iapps/enable')
    for pkg in os.listdir(PKG_INSTALL_DIR):
        if wait_for_mcpd() and wait_for_rest_worker(
                '/mgmt/shared/iapp/package-management-tasks/'):
            ext = os.path.splitext(pkg)[-1].lower()[1:]
            if ext == 'rpm':
                rpm_file_path = '%s/%s' % (PKG_INSTALL_DIR, pkg)
                (int_check,
                 sig_validated) = validate_rpm_package(rpm_file_path)
                if not int_check:
                    LOG.error('%s is not a valid RPM package or is corrupt',
                              rpm_file_path)
                    continue
                if trusted_sources and not sig_validated:
                    LOG.warning(
                        'package %s not signed by F5 Networks.. ignoring', pkg)
                    continue
                LOG.info('installing icontrol LX rpm: %s', pkg)
                LOG.info('Package Name: %s - %s',
                         get_rpm_package_name(rpm_file_path),
                         get_rpm_summary(rpm_file_path))
                LOG.info('Support for this package is handled by: %s',
                         get_rpm_packager(rpm_file_path))
                install_task_id = create_install_task(rpm_file_path)
                LOG.debug('install task is: %s', install_task_id)
                rpm_installed = False
                if install_task_id:
                    rpm_installed = query_task_until_finished(install_task_id)
                if rpm_installed:
                    LOG.debug(
                        'icontrol LX rpm %s installed.. restnoded will restart',
                        pkg)
                    time.sleep(ICONTROLLX_PACKAGE_INSTALL_DELAY)
                else:
                    LOG.error('icontrol LX rpm %s did not install properly',
                              pkg)
                wait_for_icontrollx()
            elif ext == 'fsi':
                LOG.info('running F5 Secure Installer %s', pkg)
                fsi_path = "%s/%s" % (PKG_INSTALL_DIR, pkg)
                fsi_stat = os.stat(fsi_path)
                os.chmod(fsi_path, fsi_stat.st_mode | stat.S_IEXEC)
                cilog = open(LOG_FILE, 'a+')
                subprocess.call([fsi_path, '-q'], stdout=cilog, stderr=cilog)
                wait_for_icontrollx()
            else:
                LOG.error("%s extension: %s, is not a recognized package type",
                          pkg, ext)
    return True


def download_file(source_url=None,
                  destination_folder=None,
                  destination_file=None):
    """Download AT declarations to destination folder"""
    if source_url and destination_folder:
        try:
            parsed_url = urlparse.urlparse(source_url)
            fqdn = parsed_url.netloc
            if wait_for_dns_resolution(fqdn, 120):
                LOG.debug('GET %s', source_url)
                resp = requests.get(source_url,
                                    stream=True,
                                    allow_redirects=True)
                resp.raise_for_status()
                if not destination_file:
                    cont_disp = resp.headers.get('content-disposition')
                    if cont_disp:
                        cont_disp_fn = re.findall('filename=(.+)', cont_disp)
                        if cont_disp_fn > 0:
                            destination_file = destination_folder + '/' + cont_disp_fn[0]
                            LOG.warning(
                                'download destination file set by disposition header to: %s',
                                destination_file)
                        else:
                            destination_file = destination_folder + '/' + os.path.basename(source_url)
                tmp_file = destination_file + '.part'
                if os.path.isfile(tmp_file):
                    util.del_file(tmp_file)
                with open(tmp_file, 'wb') as out_file:
                    for chunk in resp.iter_content(chunk_size=8192):
                        if chunk:
                            out_file.write(chunk)
                if os.path.isfile(tmp_file):
                    os.rename(tmp_file, destination_file)
                    return True
            LOG.error('could not copy %s to %s', source_url, destination_file)
            return False
        except Exception as err:
            LOG.error("could not download: %s - %s", source_url, err)
            return False
    else:
        return False


def phone_home(phone_home_url=None,
               do_enabled=False,
               ts_enabled=False,
               as3_enabled=False,
               status='ERROR',
               verify_tls=True,
               metadata={}):
    """Issues a Phone Home web POST request with collected onboard data"""
    if phone_home_url:
        try:
            parsed_url = urlparse.urlparse(phone_home_url)
            fqdn = parsed_url.netloc
            if wait_for_dns_resolution(fqdn, 120):
                wait_for_icontrol(timeout=120)
                installed_extensions = []
                packages = get_installed_extensions()
                for package in packages:
                    installed_extensions.append(package['name'])
                headers = {'Content-Type': 'application/json'}
                post_data = {}
                post_data['id'] = get_dmi_uuid()
                post_data['version'] = get_tmos_version()
                post_data['product'] = get_tmos_product()
                post_data['hostname'] = get_hostname()
                post_data['management'] = get_mgmt_cidr()
                post_data['installed_extensions'] = installed_extensions
                post_data['do_enabled'] = do_enabled
                post_data['ts_enabled'] = ts_enabled
                post_data['as3_enabled'] = as3_enabled
                post_data['status'] = status
                post_data['metadata'] = metadata
                post_json = json.dumps(post_data)
                LOG.debug('POST %s - %s', phone_home_url, post_json)
                if verify_tls:
                    resp = requests.post(phone_home_url,
                                         headers=headers,
                                         data=post_json)
                    resp.raise_for_status()
                else:
                    resp = requests.post(phone_home_url,
                                         headers=headers,
                                         data=post_json,
                                         verify=False)
                    resp.raise_for_status()
                return True
        except Exception as err:
            LOG.error("could not phone home: %s - %s", phone_home_url, err)
    return False


def clean():
    """Remove any onboarding artifacts"""
    if REMOVE_DHCP_LEASE_FILES:
        lease_files = os.listdir(DHCP_LEASE_DIR)
        for lease_file in lease_files:
            util.del_file("%s/%s" % (DHCP_LEASE_DIR, lease_file))
