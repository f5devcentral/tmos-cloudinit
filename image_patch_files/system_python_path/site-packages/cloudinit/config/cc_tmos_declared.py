#!/usr/bin/env python

# coding=utf-8
# pylint: disable=broad-except,unused-argument,line-too-long
# Copyright (c) 2016-2018, F5 Networks, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
This module reads f5-declarative-onboarding and f5-appsvcs-extension
declarations from userdata.

The module must be enabled in the userdata YAML to perform any
onboarding artifact generation or onboarding.

#cloud-config
tmos_declared:
  enabled: True

This module will also look for YAML metadata which typically
is handled by the cc_ssh.py module:

#cloud-config
ssh_authorized_keys:
  - ssh-rsa [key]
  - ssh-rsa [key]

The standard cloud-init cc_ssh.py module alters SELinux
configurations which may not be compatible with TMOS

Additional attributes supported in the YAML declaration
include

do_declaration - f5-declarative-onboarding declaration.

ts_declaration - f5-telemetry-streaming declaration to apply after onboarding.

as3_declaration - the f5-appsvc-3 declaration to apply after onboarding.

#cloud-config
tmos_declared:
  enabled: True
  do_declaration:
    Common:
      class: Tenant
      licenseKey:
        class: License
        licenseType: regKey
        regKey: GJKDM-UJTJH-OJZVX-ZJPEG-XTJIAHI
      provisioningLevels:
        class: Provision
        ltm: nominal
        asm: minimum
  ts_declaration:
    class: Telemetry
    schemaVersion: 1.0.0
    controls:
      class: Controls
      logLevel: debug
    Poller:
      class: Telemetry_System_Poller
      interval: 60
      enable: true
      trace: false
      allowSelfSignedCert: false
      host: localhost
      port: 8100
      protocol: http
    Beacon_Consumer:
      class: Telemetry_Consumer
      type: Generic_HTTP
      host: ingestion.ovr.prd.f5aas.com
      protocol: https
      port: 50443
      path: "/beacon/v1/ingest-telemetry-streaming"
      method: POST
      enable: true
      trace: false
      headers:
        - name: "grpc-metadata-x-f5-ingestion-token"
          value: "`>@/passphrase`"
      passphrase:
        cipherText: "h-qqdej587nnj8ikask431s-JtsPTjcposjikzKKJs78c91Auu65suAr="
  as3_declaration:
    class: AS3
    action: deploy
    persist: true
    declaration:
      class: ADC
      schemaVersion: 3.0.0

"""
import logging
import os
import subprocess
import time

from cloudinit import util
from cloudinit import tmos_onboard_utils

# constants
MODULE_NAME = 'tmos_declared'

OUT_DIR = '/var/lib/cloud/' + MODULE_NAME
EXEC_DIR = '/opt/cloud/' + MODULE_NAME

POST_ONBOARD_CMD_FILE_DIR = EXEC_DIR + '/initscripts/post'
POST_ONBOARD_FLAG_FILE = OUT_DIR + '/POST_ONBOARD_COMPLETE'

DO_DELAYED_DEPLOYMENT_SCRIPT = 'tmos_do_only_wait.py'
DELAYED_DECLARATION_SCRIPT = 'tmos_declarations_after_do.py'

TG_NOTIFY_SCRIPT = 'tmos_tg_notify.py'

LOG_FILE = '/var/log/f5-cloudinit.log'

ERROR = 'ERROR'
SUCCESS = 'SUCCESS'

tmos_onboard_utils.touch_file(LOG_FILE)

ONBOARD_TIMEOUT = 120

LOG = logging.getLogger(MODULE_NAME)
LOG.setLevel(logging.DEBUG)
FORMATTER = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
LOGFILE = logging.FileHandler(LOG_FILE)
LOGFILE.setLevel(logging.DEBUG)
LOGFILE.setFormatter(FORMATTER)
LOG.addHandler(LOGFILE)


def tmsh_cmd_dir_exists():
    """Ensures TMSH generated init script directory exists"""
    if not os.path.isdir(POST_ONBOARD_CMD_FILE_DIR):
        os.makedirs(POST_ONBOARD_CMD_FILE_DIR)
    if not os.path.isdir(OUT_DIR):
        os.makedirs(OUT_DIR)


def create_post_onboard_script(post_onboard_commands):
    """Create the post onboard command script"""
    if post_onboard_commands:
        LOG.debug('writing out post onboard commands script')
        post_onboard_commands_script = POST_ONBOARD_CMD_FILE_DIR + \
            '/001_post_onboard_commands.sh'
        if os.path.isfile(post_onboard_commands_script):
            util.del_file(post_onboard_commands_script)
        with open(post_onboard_commands_script, 'w') as pob_script:
            pob_script.write("#!/bin/bash\n")
            pob_script.write(
                "echo 'starting post onboarding commands provisioning'\n\n")
            pob_script.write("cmds=(\n")
            for cmd in post_onboard_commands:
                pob_script.write("\"%s\"\n" % cmd.replace('"', r'\"'))
            pob_script.write(")\n\n")
            pob_script.write("for (( i = 0; i < ${#cmds[@]} ; i++ )); do\n")
            pob_script.write("    echo \"Running: ${cmds[$i]}\"\n")
            pob_script.write("    eval \"${cmds[$i]}\"\n")
            pob_script.write("    if [ $? -eq 1 ]; then\n")
            pob_script.write(
                "        echo \"Command: ${cmds[$i]} Failed. Stopping execution of any further commands.\"\n"
            )
            pob_script.write("        exit 1\n")
            pob_script.write("    fi\n")
            pob_script.write("done\n\n")


def create_post_onboard():
    """Creates the initialization script for all post onboarding scripts"""
    LOG.debug('writing out post onboard initialization script')
    onboard_script = POST_ONBOARD_CMD_FILE_DIR + '/onboard.sh'
    if os.path.isfile(onboard_script):
        util.del_file(onboard_script)
    script_files = os.listdir(POST_ONBOARD_CMD_FILE_DIR)
    script_files.sort()
    with open(onboard_script, 'w') as obs:
        obs.write("#!/bin/bash\n\n")
        obs.write("function check_mcpd_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        if tmsh -a show sys mcp-state field-fmt 2> /dev/null | grep -q running; then\n"
        )
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for mcpd to reach running state'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function check_icontrol_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        started=$(curl -su 'admin:' http://localhost:8100/shared/echo | grep '\"stage\":\"STARTED\"' | wc -l 2>/dev/null)\n"
        )
        obs.write("        if [ $started == 1 ]; then\n")
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for iControl to start'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function exec_phases() {\n")
        for script_file in script_files:
            obs.write("    /bin/bash %s/%s\n" %
                      (POST_ONBOARD_CMD_FILE_DIR, script_file))
        obs.write("    echo 1 > " + POST_ONBOARD_FLAG_FILE + '\n')
        obs.write("}\n\n")
        obs.write("check_mcpd_up\n")
        obs.write("check_icontrol_up\n")
        obs.write("exec_phases\n")
    os.chmod(onboard_script, 0775)


def create_tg_actions(tgactive_url, tgstandby_url, tgrefresh_url):
    """adds action scripts to call webhooks if defined"""
    if tgactive_url:
        inject_tg_action_script('active')
    if tgstandby_url:
        inject_tg_action_script('standby')
    if tgrefresh_url:
        inject_tg_action_script('refresh')


def is_tg_action_injected(action, script_name):
    """ check if script is injected into /config/startup """
    injected_already = subprocess.Popen(
        "cat /config/failover/tg%s | grep %s | wc -l" % (action, script_name),
        stdout=subprocess.PIPE,
        shell=True).communicate()[0].replace('\n', '')
    if injected_already == '0':
        return False
    return True


def inject_tg_action_script(action):
    """ insert script to run on tg state change action """
    notify_script_name = "%s/%s" % (os.path.dirname(
        os.path.realpath(__file__)), TG_NOTIFY_SCRIPT)
    if not is_tg_action_injected(action, notify_script_name):
        LOG.info('injecting tg action script %s into /config/failover/tg%s',
                 notify_script_name, action)
        with open('/config/failover/tg%s' % action, 'a+') as tgas:
            tgas.write("/usr/bin/env python %s %s ${1} %s\n" %
                       (notify_script_name, MODULE_NAME, action))


def is_startup_injected(script_name):
    """ check if script is injected into /config/startup """
    injected_already = subprocess.Popen(
        "cat /config/startup | grep " + script_name + " | wc -l",
        stdout=subprocess.PIPE,
        shell=True).communicate()[0].replace('\n', '')
    if injected_already == '0':
        return False
    return True


def run_do_wait():
    """ run the do wait script """
    deploy_script_name = "%s/%s" % (os.path.dirname(
        os.path.realpath(__file__)), DO_DELAYED_DEPLOYMENT_SCRIPT)
    if not is_startup_injected(DO_DELAYED_DEPLOYMENT_SCRIPT):
        LOG.info(
            'injecting f5-declarative-onboard wait script %s into /config/startup',
            deploy_script_name)
        with open('/config/startup', 'a+') as css:
            css.write("/usr/bin/env python %s %s &\n" %
                      (deploy_script_name, MODULE_NAME))
    LOG.info('running f5-declarative-onboard wait script %s',
             deploy_script_name)
    subprocess.call(
        ['/usr/bin/env', 'python', deploy_script_name, MODULE_NAME, '&'])


def run_declarations_deffered():
    """ run the declarations deferred deployment script """
    deploy_script_name = "%s/%s" % (os.path.dirname(
        os.path.realpath(__file__)), DELAYED_DECLARATION_SCRIPT)
    if not is_startup_injected(DELAYED_DECLARATION_SCRIPT):
        LOG.info(
            'injecting declaration delayed deployment script %s into /config/startup',
            deploy_script_name)
        with open('/config/startup', 'a+') as css:
            css.write("/usr/bin/env python %s %s &\n" %
                      (deploy_script_name, MODULE_NAME))
    LOG.info('running declaration delayed deployment script %s',
             deploy_script_name)
    subprocess.call(
        ['/usr/bin/env', 'python', deploy_script_name, MODULE_NAME, '&'])


def run_post_onboard_commands():
    """ run the post onboarding commands """
    post_onboard_script = POST_ONBOARD_CMD_FILE_DIR + '/onboard.sh'
    with open(LOG_FILE, 'a+') as onboardlog:
        LOG.info('running post onboard script')
        subprocess.call(['nohup', 'sh', '-c', post_onboard_script, '&'],
                        stdout=onboardlog,
                        stderr=onboardlog)
        end_time = time.time() + ONBOARD_TIMEOUT
        while (end_time - time.time()) > 0:
            if not os.path.exists(POST_ONBOARD_FLAG_FILE):
                time.sleep(1)
            else:
                end_time = 0
        if not os.path.exists(POST_ONBOARD_FLAG_FILE):
            LOG.error('post onboard commands did not complete properly')
            return False
        return True


def onboard(do_declaration, do_declaration_url, do_declaration_url_headers, do_template_variables,
            as3_declaration, as3_declaration_url, as3_declaration_url_headers, as3_template_variables,
            ts_declaration, ts_declaration_url, ts_declaration_url_headers, ts_template_variables,
            trusted_sources, post_onboard_enabled, post_onboard_commands,
            phone_home_url, phone_home_url_headers, phone_home_url_verify_tls, phone_home_url_metadata,
            phone_home_cli):
    """Implements the onboarding business logic"""

    do_enabled = True
    try:
        tmos_onboard_utils.persist_do_declaration(
            None,
            do_declaration,
            do_declaration_url,
            do_declaration_url_headers,
            do_template_variables)
    except Exception as err:
        LOG.error(
            'could not persist f5-declarative-onboarding declaration: %s', err)
        do_enabled = False

    ts_enabled = True
    if ts_declaration:
        try:
            tmos_onboard_utils.persist_ts_declaration(ts_declaration)
        except Exception as err:
            LOG.error(
                'could not persist f5-telemetry-streaming declaration %s', err)
            ts_enabled = False
    elif ts_declaration_url:
        try:
            tmos_onboard_utils.download_ts_declaration(
                ts_declaration_url,
                ts_declaration_url_headers,
                ts_template_variables)
        except Exception as err:
            LOG.error(
                'could not download f5-telemetry-streaming declaration %s',
                err)
            ts_enabled = False

    as3_enabled = True
    if as3_declaration:
        try:
            tmos_onboard_utils.persist_as3_declaration(as3_declaration)
        except Exception as err:
            LOG.error('could not persist f5-appsvcs-extension declaration %s',
                      err)
            as3_enabled = False
    elif as3_declaration_url:
        try:
            tmos_onboard_utils.download_as3_declaration(
                as3_declaration_url,
                as3_declaration_url_headers,
                as3_template_variables)
        except Exception as err:
            LOG.error('could not download f5-appsvcs-extension declaration %s',
                      err)
            as3_enabled = False

    if post_onboard_enabled:
        tmsh_cmd_dir_exists()
        create_post_onboard_script(post_onboard_commands)
        create_post_onboard()

    if not tmos_onboard_utils.is_mgmt_ip:
        LOG.debug('waiting on mgmt interface provisioning to complete')
        tmos_onboard_utils.wait_for_mgmt_dhcp(timeout=600)

    LOG.debug('waiting for mcpd to become available')
    tmos_onboard_utils.wait_for_mcpd()

    LOG.debug('waiting for iControl to become available')
    tmos_onboard_utils.wait_for_icontrol()

    LOG.info('installing discovered iControl LX extensions')
    tmos_onboard_utils.install_extensions(trusted_sources)

    if do_enabled or ts_enabled or as3_enabled:
        icontrol_available = False
        for _ in range(5):
            if tmos_onboard_utils.wait_for_icontrollx(timeout=30):
                icontrol_available = True
                break
            time.sleep(1)
        if not icontrol_available:
            LOG.error('iControl LX never became available.. timeout...')
            LOG.error('check /var/log/restnoded/restnoded.log for errors')
            LOG.error('disabling iControl LX declarations..')
            do_enabled = False
            as3_enabled = False
            ts_enabled = False

        LOG.debug('waiting for iControl LX interfaces to be available')
        tmos_onboard_utils.wait_for_icontrollx()

    do_posted = False
    if do_enabled:
        do_available = False
        for _ in range(5):
            if tmos_onboard_utils.wait_for_rest_worker(
                    '/mgmt/shared/declarative-onboarding', timeout=30):
                do_available = True
                break
            time.sleep(1)
        if do_available:
            if tmos_onboard_utils.do_declare():
                do_posted = True
        else:
            LOG.error(
                'f5-declarative-onboarding never became available.. timeout...'
            )
            LOG.error('check /var/log/restnoded/restnoded.log for errors')

    onboard_status = SUCCESS
    if do_enabled and not do_posted:
        # DO enabled, initial post failed (bad declaration syntax)
        # fail the phone_home_url
        onboard_status = ERROR
    elif do_posted and (ts_enabled or as3_enabled):
        # DO enabled, posted async, need to background AS3 - phone home deferred to background AS3 process
        run_declarations_deffered()
        return
    elif do_posted and not (ts_enabled or as3_enabled):
        run_do_wait()
        return
    elif ts_enabled or as3_enabled:
        # DO not enabled, run AS3 declaration now
        # reset restnoded to over come AS3 issue
        # https://github.com/F5Networks/f5-appsvcs-extension/issues/108
        tmos_onboard_utils.bigstart_restart('restnoded')
        tmos_onboard_utils.wait_for_icontrollx()

        if ts_enabled and (not onboard_status == ERROR):
            ts_available = False
            for _ in range(5):
                if tmos_onboard_utils.wait_for_rest_worker(
                        '/mgmt/shared/telemetry/declare', timeout=30):
                    ts_available = True
                    break
                time.sleep(1)
            if ts_available:
                # check if there was a previous declaration.. if so don't issue
                response = tmos_onboard_utils.get_ts_declaration()
                # we have to check the format of the reponse because AS3
                # does not assure the response is valid JSON
                if hasattr(response, 'status_code'):
                    if response.status_code == 204 or response.status_code == 200:
                        LOG.info(
                            'making initial f5-telemetry-streaming declaration'
                        )
                        ts_declared = tmos_onboard_utils.ts_declare()
                        if not ts_declared:
                            LOG.error(
                                'f5-telemetry-streaming inital declaration failed'
                            )
                            onboard_status = ERROR
                        else:
                            LOG.info(
                                'f5-telemetry-streaming initial declaration submitted successfully'
                            )
                            if post_onboard_enabled:
                                if not run_post_onboard_commands:
                                    onboard_status = ERROR
                    else:
                        LOG.warn(
                            'f5-telemetry-streaming has a previously errored declaration, not deploying'
                        )
                        onboard_status = ERROR
                else:
                    LOG.error(
                        'f5-telemetry-streaming has failed, not deploying initial declaration declaration %s - %s',
                        response.status_code, response.text)
                    onboard_status = ERROR
            else:
                LOG.error(
                    'f5-telemetry-streaming never became available.. timeout...'
                )
                LOG.error('check /var/log/restnoded/restnoded.log for errors')
                onboard_status = ERROR

        if as3_enabled and (not onboard_status == ERROR):
            # this logic was added because AS3 performs hidden tasks
            # after it is started that can only be assured when
            # AS3 endpoint returns a response
            as3_available = False
            for _ in range(5):
                if tmos_onboard_utils.wait_for_rest_worker(
                        '/mgmt/shared/appsvcs/declare', timeout=30):
                    as3_available = True
                    break
                time.sleep(1)

            if as3_available:
                # check if there was a previous declaration.. if so don't issue
                response = tmos_onboard_utils.get_as3_declaration()
                # we have to check the format of the reponse because AS3
                # does not assure the response is valid JSON
                if hasattr(response, 'status_code'):
                    if response.status_code == 204 or response.status_code == 200:
                        LOG.info(
                            'making initial f5-appsvcs-extension declaration')
                        as3_declared = tmos_onboard_utils.as3_declare()
                        if not as3_declared:
                            LOG.error(
                                'f5-appsvcs-extension inital declaration failed'
                            )
                            onboard_status = ERROR
                        else:
                            LOG.info(
                                'f5-appsvcs-extension initial declaration submitted successfully'
                            )
                            if post_onboard_enabled:
                                if not run_post_onboard_commands:
                                    onboard_status = ERROR
                    else:
                        LOG.warn(
                            'f5-appsvcs-extension has a previously errored declaration, not deploying'
                        )
                        onboard_status = ERROR
                else:
                    LOG.error(
                        'f5-appsvcs-extension has failed, not deploying initial declaration declaration %s - %s',
                        response.status_code, response.text)
                    onboard_status = ERROR
            else:
                LOG.error(
                    'f5-appsvcs-extension never became available.. timeout...')
                LOG.error('check /var/log/restnoded/restnoded.log for errors')
                onboard_status = ERROR
    else:
        # neither DO or AS3 enabled
        if post_onboard_enabled:
            if not run_post_onboard_commands():
                onboard_status = ERROR

    if phone_home_url:
        tmos_onboard_utils.phone_home(phone_home_url, phone_home_url_headers,
                                      do_enabled, ts_enabled,
                                      as3_enabled, onboard_status,
                                      phone_home_url_verify_tls,
                                      phone_home_url_metadata)
    if phone_home_cli and onboard_status == SUCCESS:
        tmos_onboard_utils.run_cmd(phone_home_cli)

    LOG.info('onboarding ended with status: %s', onboard_status)


def handle(name, cloud_config, cloud, log, args):
    """Cloud-init processing function"""
    tag = MODULE_NAME
    enabled = False

    if tag in cloud_config:
        try:
            enabled = bool(cloud_config[tag]['enabled'])
        except Exception:
            LOG.error('%s missing enabled.. exiting', tag)
            return

    if enabled:
        LOG.info("%s enabled", tag)
        keys = []
        if "ssh_authorized_keys" in cloud_config:
            cfgkeys = cloud_config["ssh_authorized_keys"]
            keys.extend(cfgkeys)
            LOG.info('%s found ssh_authorized_keys', tag)
        tmos_onboard_utils.inject_public_ssh_keys(keys)

        # download referenced extensions
        icontrollx_trusted_sources = True
        if 'icontrollx_trusted_sources' in cloud_config[tag]:
            icontrollx_trusted_sources = cloud_config[tag][
                'icontrollx_trusted_sources']
        icontrollx_package_urls = []
        if 'icontrollx_package_urls' in cloud_config[tag]:
            icontrollx_package_urls = cloud_config[tag][
                'icontrollx_package_urls']
            LOG.info('%s found icontrollx_package_urls', tag)
        for ext_url in icontrollx_package_urls:
            LOG.info('downloading: %s', ext_url)
            if tmos_onboard_utils.download_extension(ext_url):
                LOG.info(
                    'extension %s downloaded in discovered iControl extensions',
                    ext_url)
            else:
                LOG.error('exenstion %s could not be donwloaded', ext_url)

        do_declaration = None
        if 'do_declaration' in cloud_config[tag]:
            do_declaration = cloud_config[tag]['do_declaration']
            LOG.info('%s found do_declaration', tag)
        do_declaration_url = None
        if 'do_declaration_url' in cloud_config[tag]:
            do_declaration_url = cloud_config[tag]['do_declaration_url']
            LOG.info('%s downloading do_declaration', tag)
        do_declaration_url_headers = None
        if 'do_declaration_url_headers' in cloud_config[tag]:
            do_declaration_url_headers = cloud_config[tag]['do_declaration_url_headers']
        do_template_variables = None
        if 'do_template_variables' in cloud_config[tag]:
            do_template_variables = cloud_config[tag]['do_template_variables']
            LOG.info('%s templating downloaded do_declaration', tag)
        ts_declaration = None
        if 'ts_declaration' in cloud_config[tag]:
            ts_declaration = cloud_config[tag]['ts_declaration']
            LOG.info('%s found ts_declaration', tag)
        ts_declaration_url = None
        if 'ts_declaration_url' in cloud_config[tag]:
            ts_declaration_url = cloud_config[tag]['ts_declaration_url']
            LOG.info('%s downloading ts_declaration', tag)
        ts_declaration_url_headers = None
        if 'ts_declaration_url_headers' in cloud_config[tag]:
            ts_declaration_url_headers = cloud_config[tag]['ts_declaration_url_headers']
        ts_template_variables = None
        if 'ts_template_variables' in cloud_config[tag]:
            ts_template_variables = cloud_config[tag]['ts_template_variables']
            LOG.info('%s templating downloaded ts_declaration', tag)
        as3_declaration = None
        if 'as3_declaration' in cloud_config[tag]:
            as3_declaration = cloud_config[tag]['as3_declaration']
            LOG.info('%s found as3_declaration', tag)
        as3_declaration_url = None
        if 'as3_declaration_url' in cloud_config[tag]:
            as3_declaration_url = cloud_config[tag]['as3_declaration_url']
            LOG.info('%s downloading as3_declaration', tag)
        as3_declaration_url_headers = None
        if 'as3_declaration_url_headers' in cloud_config[tag]:
            as3_declaration_url_headers = cloud_config[tag]['as3_declaration_url_headers']
        as3_template_variables = None
        if 'as3_template_variables' in cloud_config[tag]:
            as3_template_variables = cloud_config[tag][
                'as3_template_variables']
            LOG.info('%s templating downloaded as3_declaration', tag)
        post_onboard_enabled = False
        if 'post_onboard_enabled' in cloud_config[tag]:
            post_onboard_enabled = bool(
                cloud_config[tag]['post_onboard_enabled'])
        post_onboard_commands = []
        if 'post_onboard_commands' in cloud_config[tag]:
            post_onboard_commands = cloud_config[tag]['post_onboard_commands']

        phone_home_url = None
        if 'phone_home_url' in cloud_config[tag]:
            phone_home_url = cloud_config[tag]['phone_home_url']

        phone_home_url_headers = None
        if 'phone_home_url_headers' in cloud_config[tag]:
            phone_home_url_headers = cloud_config[tag]['phone_home_url_headers']

        phone_home_url_verify_tls = True
        if 'phone_home_url_verify_tls' in cloud_config[tag]:
            phone_home_url_verify_tls = cloud_config[tag][
                'phone_home_url_verify_tls']

        phone_home_url_metadata = {}
        if 'phone_home_url_metadata' in cloud_config[tag]:
            phone_home_url_metadata = cloud_config[tag][
                'phone_home_url_metadata']

        phone_home_cli = None
        if 'phone_home_cli' in cloud_config[tag]:
            phone_home_cli = cloud_config[tag]['phone_home_cli']

        tgactive_url = None
        if 'tgactive_url' in cloud_config[tag]:
            tgactive_url = cloud_config[tag]['tgactive_url']
        tgstandby_url = None
        if 'tgstandby_url' in cloud_config[tag]:
            tgstandby_url = cloud_config[tag]['tgstandby_url']
        tgrefresh_url = None
        if 'tgrefresh_url' in cloud_config[tag]:
            tgrefresh_url = cloud_config[tag]['tgrefresh_url']

        create_tg_actions(tgactive_url, tgstandby_url, tgrefresh_url)

        try:
            onboard(do_declaration,
                    do_declaration_url,
                    do_declaration_url_headers,
                    do_template_variables,
                    as3_declaration,
                    as3_declaration_url,
                    as3_declaration_url_headers,
                    as3_template_variables,
                    ts_declaration,
                    ts_declaration_url,
                    ts_declaration_url_headers,
                    ts_template_variables,
                    icontrollx_trusted_sources,
                    post_onboard_enabled,
                    post_onboard_commands,
                    phone_home_url,
                    phone_home_url_headers,
                    phone_home_url_verify_tls,
                    phone_home_url_metadata,
                    phone_home_cli)
        except Exception as err:
            LOG.error('onboard exception - %s', err)
        try:
            tmos_onboard_utils.clean()
        except Exception as err:
            LOG.error('onboard cleanup exception - %s', err)


if __name__ == "__main__":
    # Running the cloud-init module from the CLI python interpreter
    CLOUD_CONFIG_FILE = '/opt/cloud/instance/cloud-config.txt'
    CLOUD_CONFIG = {
        MODULE_NAME: {
            'enabled': True,
            'do_declaration': {},
            'ts_declaration': {},
            'as3_declaration': {}
        }
    }
    if os.path.exists(CLOUD_CONFIG_FILE):
        CLOUD_CONFIG = util.read_conf(CLOUD_CONFIG_FILE)
    handle(MODULE_NAME, CLOUD_CONFIG, None, logging, [])
