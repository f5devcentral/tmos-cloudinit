#!/usr/bin/env python

# coding=utf-8
# pylint: disable=broad-except,unused-argument,line-too-long
# Copyright (c) 2016-2018, F5 Networks, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
This module reads metadata from DHCPv4 requests made on TMM interfaces.

The module must be enabled in the userdata YAML to perform any
onboarding artifact generation or onboarding.

#cloud-config
tmos_dhcpv4_tmm:
  enabled: True

This module will also look for YAML metadata which typically
is handled by the cc_ssh.py module:

#cloud-config
ssh_authorized_keys:
  - ssh-rsa [key]
  - ssh-rsa [key]

The standard cloud-init cc_ssh.py module alters SELinux
configurations which may not be compatible with TMOS

Additional attributes supported in the YAML declaration
include

rd_enabled - Route domain decoration support, defaults to True.

do_enables - f5-declarative-onboarding support, defaults to True.

ts_enabled - f5-telemetry-streaming support, defaults to True.

as3_enabled - f5-appsvcs-extension support, defaults to True.

configsync_interface - implicitly define the TMOS configsync interface.

default_route_interface - implicitly defint the TMOS default route interface.

do_declaration - f5-declarative-onboarding declaration to overwrite/merge
                 with the metadata generated declaration.

ts_declaration - f5-telemetry-streaming declaration to apply after onboarding.

as3_declaration - the f5-appsvc-3 declaration to apply after onboarding.

#cloud-config
tmos_dhcpv4_tmm:
  enabled: True
  rd_enabled: False
  do_enabled: True
  ts_enabled: True
  as3_enable: True
  configsync_interface: 1.1
  default_route_interface: 1.3
  do_declaration:
    Common:
      class: Tenant
      licenseKey:
        class: License
        licenseType: regKey
        regKey: GJKDM-UJTJH-OJZVX-ZJPEG-XTJIAHI
      provisioningLevels:
        class: Provision
        ltm: nominal
        asm: minimum
  ts_declaration:
    class: Telemetry
    schemaVersion: 1.0.0
    controls:
      class: Controls
      logLevel: debug
    Poller:
      class: Telemetry_System_Poller
      interval: 60
      enable: true
      trace: false
      allowSelfSignedCert: false
      host: localhost
      port: 8100
      protocol: http
    Beacon_Consumer:
      class: Telemetry_Consumer
      type: Generic_HTTP
      host: ingestion.ovr.prd.f5aas.com
      protocol: https
      port: 50443
      path: "/beacon/v1/ingest-telemetry-streaming"
      method: POST
      enable: true
      trace: false
      headers:
        - name: "grpc-metadata-x-f5-ingestion-token"
          value: "`>@/passphrase`"
      passphrase:
        cipherText: "h-qqdej587nnj8ikask431s-JtsPTjcposjikzKKJs78c91Auu65suAr="
  as3_declaration:
    class: AS3
    action: deploy
    persist: true
    declaration:
      class: ADC
      schemaVersion: 3.0.0

"""
import logging
import os
import subprocess
import socket
import time

from cloudinit import util
from cloudinit import tmos_onboard_utils

# constants
MODULE_NAME = 'tmos_dhcpv4_tmm'

OUT_DIR = '/var/lib/cloud/' + MODULE_NAME
EXEC_DIR = '/opt/cloud/' + MODULE_NAME

PRE_DO_TMSH_CMD_FILE_DIR = EXEC_DIR + '/initscripts/all'
NON_DO_TMSH_CMD_FILE_DIR = EXEC_DIR + '/initscripts/non_declared'
POST_ONBOARD_CMD_FILE_DIR = EXEC_DIR + '/initscripts/post'

LOG_FILE = '/var/log/f5-cloudinit.log'

PRE_DO_ONBOARD_COMPLETE_FLAG_FILE = OUT_DIR + '/PRE_DO_ONBOARD_COMPLETE'
NON_DO_ONBOARD_COMPLETE_FLAG_FILE = OUT_DIR + '/NON_DO_ONBOARD_COMPLETE'
POST_ONBOARD_FLAG_FILE = OUT_DIR + '/POST_ONBOARD_COMPLETE'
RPM_INSTALL_PROGRESS_FLAG_FILE_PREFIX = OUT_DIR + 'ICONTROL_LX_INSTALL_'

DEFAULT_DNS_SERVERS = ['8.8.8.8', '8.8.4.4']
DEFAULT_NTP_SERVERS = ['0.pool.ntp.org', '1.pool.ntp.org']
DEFAULT_TIMEZONE = 'UTC'
DEFAULT_CONFIGSYNC_INTERFACE = '1.1'

REMOVE_METADATA_FILES = False

ONBOARD_TIMEOUT = 120

DO_TIMEOUT = 3600

DO_DELAYED_DEPLOYMENT_SCRIPT = 'tmos_do_only_wait.py'
DELAYED_DECLARATION_SCRIPT = 'tmos_declarations_after_do.py'

TG_NOTIFY_SCRIPT = 'tmos_tg_notify.py'

ERROR = 'ERROR'
SUCCESS = 'SUCCESS'

tmos_onboard_utils.touch_file(LOG_FILE)

LOG = logging.getLogger(MODULE_NAME)
LOG.setLevel(logging.DEBUG)
FORMATTER = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
LOGFILE = logging.FileHandler(LOG_FILE)
LOGFILE.setLevel(logging.DEBUG)
LOGFILE.setFormatter(FORMATTER)
LOG.addHandler(LOGFILE)


def tmsh_cmd_dir_exists():
    """Ensures TMSH generated init script directory exists"""
    if not os.path.isdir(PRE_DO_TMSH_CMD_FILE_DIR):
        os.makedirs(PRE_DO_TMSH_CMD_FILE_DIR)
    if not os.path.isdir(NON_DO_TMSH_CMD_FILE_DIR):
        os.makedirs(NON_DO_TMSH_CMD_FILE_DIR)
    if not os.path.isdir(POST_ONBOARD_CMD_FILE_DIR):
        os.makedirs(POST_ONBOARD_CMD_FILE_DIR)
    if not os.path.isdir(OUT_DIR):
        os.makedirs(OUT_DIR)


# inject discovered SSH keys, we don't use the ssh_keys cloud-init module
# because it uses SELinuxGuard, which we don't know will always be
# safe with TMOS versions
def inject_public_ssh_keys(log, keys):
    """Injects discovered and metadata supplied SSH keys into the root account"""
    LOG.debug('injecting root SSH keys')
    if not keys:
        keys = []
    try:
        tmos_onboard_utils.inject_public_ssh_keys(keys)
    except Exception as err:
        LOG.error('exception in injecting SSH keys: %s', err)


def initialize_do_declaration():
    """Returns the f5-declarative-onboarding declaration header items"""
    LOG.debug('intializing f5-declarative-onboarding declaration')
    return {
        'schemaVersion': "1.0.0",
        'class': 'Device',
        'async': True,
        'label': 'generated from DHCPv4 metadata',
        'Common': {
            'class': 'Tenant'
        }
    }


def get_linux_interfaces():
    """Return a list of linux link device names"""
    if tmos_onboard_utils.is_tmm():
        tmos_onboard_utils.stop_tmm()
    interfaces = subprocess.Popen(
        "ip link | egrep 'eth[1-9]' | cut -d':' -f2 | tr -d ' '",
        stdout=subprocess.PIPE,
        shell=True).communicate()[0].split('\n')
    return interfaces


def resolve_resources(rd_enabled=True,
                      default_route_interface=None,
                      configsync_interface=None,
                      inject_routes=True,
                      do_enabled=False,
                      dhcp_timeout=120,
                      dhcpv4_options=None):
    """Resolve the resource provisioning dataset from metadata"""
    do_declaration = None
    if do_enabled:
        do_declaration = initialize_do_declaration()
    if default_route_interface:
        LOG.debug('default_route_interface %s requested',
                  default_route_interface)
    else:
        LOG.debug(
            'no default_route_interface designated, will attempt to select dynamically'
        )
    if not configsync_interface:
        configsync_interface = DEFAULT_CONFIGSYNC_INTERFACE
    LOG.debug('setting configsync_interface to %s', configsync_interface)
    # resolved resources
    links, selfips, routes, services = {}, {}, {}, {}
    m_ip = m_nm = m_gw = None
    m_mtu = 1500
    dns_services = []
    ntp_services = []
    number_of_default_routes = 0
    onenic = tmos_onboard_utils.is_onenic()
    # resolve data from mgmt interface DHCPv4 lease
    try:
        mgmt_data = tmos_onboard_utils.process_dhcp4_lease(
            tmos_onboard_utils.MGMT_DHCP_LEASE_FILE)
        opts = None
        if dhcpv4_options and 'mgmt' in dhcpv4_options:
            opts = dhcpv4_options['mgmt']
        if 'fixed-address' in mgmt_data:
            m_ip = mgmt_data['fixed-address']
        if opts and 'fixed-address' in opts:
            LOG.info(
                "overriding mgmt fixed-address from user-data supplied option to: %s",
                opts['fixed-address'])
            m_ip = opts['fixed-address']
        if 'subnet-mask' in mgmt_data:
            m_nm = mgmt_data['subnet-mask']
        if opts and 'subnet-mask' in opts:
            LOG.info(
                "overriding mgmt subnet-mask from user-data supplied option to: %s",
                opts['subnet-mask'])
            m_nm = opts['subnet-mask']
        if 'interface-mtu' in mgmt_data:
            m_mtu = int(mgmt_data['interface-mtu'])
        if opts and 'interface-mtu' in opts:
            LOG.info(
                "overriding mgmt interface-mtu from user-data supplied option to: %s",
                opts['interface-mtu'])
            m_mtu = opts['interface-mtu']
        if 'routers' in mgmt_data:
            m_gw = mgmt_data['routers']
        if opts and 'routers' in opts:
            LOG.info(
                "overriding mgmt routers from user-data supplied option to: %s",
                opts['routers'])
            m_gw = opts['routers']
        if 'host-name' in mgmt_data:
            services['hostname'] = mgmt_data['host-name']
        if opts and 'host-name' in opts:
            LOG.info(
                "overriding mgmt host-name from user-data supplied option to: %s",
                opts['host-name'])
            services['hostname'] = opts['host-name']
        if 'domain-name' in mgmt_data:
            services['domainname'] = mgmt_data['domain-name']
        if opts and 'domain-name' in opts:
            LOG.info(
                "overriding mgmt domain-name from user-data supplied option to: %s",
                opts['domain-name'])
            services['domainname'] = opts['domain-name']
        dns_servers = None
        if 'domain-name-servers' in mgmt_data:
            LOG.debug('discovered DNS service configuration')
            dns_servers = mgmt_data['domain-name-servers']
        if opts and 'domain-name-servers' in opts:
            LOG.info(
                "overriding mgmt domain-name-servers from user-data supplied option to: %s",
                opts['domain-name-servers'])
            dns_servers = opts['domain-name-servers']
        if dns_servers:
            if ',' in dns_servers:
                dns_servers = dns_servers.replace(',', ' ')
            for dns in dns_servers.split(' '):
                dns_services.append(dns)
        ntp_servers = None
        if 'ntp-servers' in mgmt_data:
            LOG.debug('discovered NTP service configuration')
            ntp_servers = mgmt_data['ntp-servers']
        if opts and 'ntp-servers' in opts:
            LOG.info(
                "overriding mgmt ntp-servers from user-data supplied option to: %s",
                opts['ntp-servers'])
            ntp_servers = opts['ntp-servers']
        if ntp_servers:
            if ',' in ntp_servers:
                ntp_servers = ntp_servers.replace(',', ' ')
            for ntp in ntp_servers.split(' '):
                ntp_services.append(ntp)
    except Exception as err:
        LOG.error('exception in processing mgmt DHCPv4 lease file: %s', err)

    tmos_onboard_utils.force_tmm_down()
    for interface in get_linux_interfaces():
        if interface:
            int_index = int(interface[3:])
            tmm_interface_name = '1.' + str(int_index)
            net_name = 'net_%s' % tmm_interface_name
            net_name = net_name.replace('.', '_')
            links[tmm_interface_name] = {
                'net_name': net_name,
                'mtu': 1500,
                'interface': tmm_interface_name,
                'route_domain': 0,
                'interface_index': int_index,
                'segmentation_id': 4094 - int_index,
                'tagged': False
            }
            s_ip = s_nm = s_gw = s_routes = None
            try:
                if tmos_onboard_utils.make_dhcp4_request(
                        interface, dhcp_timeout):
                    opts = None
                    if dhcpv4_options and tmm_interface_name in dhcpv4_options:
                        opts = dhcpv4_options[tmm_interface_name]
                    interface_data = tmos_onboard_utils.process_dhcp4_lease(
                        interface)
                    if 'fixed-address' in interface_data:
                        s_ip = interface_data['fixed-address']
                    if opts and 'fixed-address' in opts:
                        LOG.info(
                            "overriding %s fixed-address from user-data supplied option to: %s",
                            tmm_interface_name, opts['fixed-address'])
                        s_ip = opts['fixed-address']
                    if 'subnet-mask' in interface_data:
                        s_nm = interface_data['subnet-mask']
                    if opts and 'subnet-mask' in opts:
                        LOG.info(
                            "overriding %s subnet-mask from user-data supplied option to: %s",
                            tmm_interface_name, opts['subnet-mask'])
                        s_nm = opts['subnet-mask']
                    if 'routers' in interface_data:
                        s_gw = interface_data['routers']
                    if opts and 'routers' in opts:
                        LOG.info(
                            "overriding %s routers from user-data supplied option to: %s",
                            tmm_interface_name, opts['routers'])
                        s_gw = opts['routers']
                    if 'classless-static-routes' in interface_data:
                        s_routes = interface_data['classless-static-routes']
                    if opts and 'classless-static-routes' in opts:
                        LOG.info(
                            "overriding %s classless-static-routes from user-data supplied option to: %s",
                            tmm_interface_name,
                            opts['classless-static-routes'])
                        s_routes = opts['classless-static-routes']
                    s_mtu = 1500
                    if 'interface-mtu' in interface_data:
                        s_mtu = interface_data['interface-mtu']
                    if opts and 'interface-mtu' in opts:
                        LOG.info(
                            "overriding %s interface-mtu from user-data supplied option to: %s",
                            tmm_interface_name, opts['interface-mtu'])
                        s_mtu = opts['interface-mtu']
                    routes[tmm_interface_name] = []
                    use_rd_on_this_link = True
                    if s_ip:
                        # vlans
                        links[tmm_interface_name]['mtu'] = s_mtu
                        # selfips
                        selfip_name = 'selfip_%s' % tmm_interface_name
                        selfip_name = selfip_name.replace('.', '_')
                        selfips[tmm_interface_name] = {
                            'selfip_name': selfip_name,
                            'net_name': net_name,
                            'ip_address': s_ip,
                            'netmask': s_nm
                        }
                        # default gateway from DHCPv4
                        if s_gw and s_gw != m_gw:
                            route = {}
                            inject_route = True
                            route['use_rd'] = True
                            route['exclude'] = False
                            if default_route_interface == links[
                                    tmm_interface_name]['interface']:
                                LOG.debug(
                                    'default_route_interface discovered with DHCPv4 as interface: %s gw: %s',
                                    links[tmm_interface_name]['interface'],
                                    s_gw)
                                route['use_rd'] = False
                                number_of_default_routes += 1
                            if configsync_interface == links[
                                    tmm_interface_name]['interface']:
                                LOG.debug(
                                    'configsync_interface discovered with DHCPv4 as link: %s',
                                    tmm_interface_name)
                                route['use_rd'] = False
                                if not default_route_interface == configsync_interface:
                                    inject_route = False
                            if (not default_route_interface) and (
                                    number_of_default_routes == 0
                                    and inject_route):
                                LOG.debug(
                                    'dynamically setting default_route_interface with DHCPv4 interface: %s gw: %s',
                                    links[tmm_interface_name]['interface'],
                                    s_gw)
                                route['use_rd'] = False
                                use_rd_on_this_link = False
                                number_of_default_routes += 1
                            route['route_name'] = net_name + '_default_gw'
                            route['network'] = '0.0.0.0'
                            route['netmask'] = '0.0.0.0'
                            route['gateway'] = s_gw
                            if inject_route and inject_routes:
                                routes[tmm_interface_name].append(route)
                        # resolve static routes
                        for route in tmos_onboard_utils.process_dhcp4_routes(
                                s_routes):
                            route['use_rd'] = True
                            route['exclude'] = False
                            if default_route_interface == links[
                                    tmm_interface_name]['interface']:
                                route['use_rd'] = False
                            if configsync_interface == links[
                                    tmm_interface_name]['interface']:
                                route['use_rd'] = False
                            if not use_rd_on_this_link:
                                route['use_rd'] = False
                            if inject_routes:
                                routes[tmm_interface_name].append(route)
                    else:
                        if default_route_interface == links[
                                tmm_interface_name]['interface']:
                            LOG.warn(
                                'the requested default_route_interface self IP could not be resolved'
                            )
                        if configsync_interface == links[tmm_interface_name][
                                'interface']:
                            LOG.warn(
                                'the requested configsync_interface self IP could not be resolved'
                            )
            except Exception as err:
                LOG.error('exception processing DHCPv4 for interface %s - %s',
                          interface, err)
    if rd_enabled:
        LOG.debug('decorating route domains')
        for tmm_int in routes:
            for route in routes[tmm_int]:
                if route['use_rd']:
                    r_dom = str(links[tmm_int]['segmentation_id'])
                    links[tmm_int]['route_domain'] = r_dom
                    if selfips[tmm_int]['ip_address'].find('%') < 0:
                        selfips[tmm_int]['ip_address'] = selfips[tmm_int][
                            'ip_address'] + '%' + r_dom
                    route['route_name'] = route['route_name'] + '_' + r_dom
                    route['network'] = route['network'] + '%' + r_dom
                    route['gateway'] = route['gateway'] + '%' + r_dom
    else:
        for tmm_int in routes:
            for route in routes[tmm_int]:
                if route['use_rd'] and (route['network'] == '0.0.0.0'
                                        or route['network'] == '::'):
                    LOG.warn(
                        'excluding default route on link %s because route domains disabled',
                        tmm_int)
                    route['exclude'] = True

    LOG.debug('resolving service resources')
    if 'hostname' not in services:
        syshostname = socket.gethostname()
        if syshostname.startswith('localhost'):
            LOG.warn('forcing device hostname to: bigip')
            services['hostname'] = 'bigip'
            services['domainname'] = '.local'
        else:
            try:
                first_dot = syshostname.index('.')
                services['hostname'] = syshostname[:first_dot]
                services['domainame'] = syshostname[first_dot + 1:]
            except ValueError:
                services['hostname'] = syshostname
    if 'domainname' not in services:
        LOG.warn('forcing device domainname to .local')
        services['domainname'] = 'local'
    declared_hostname = "%s.%s" % (services['hostname'],
                                   services['domainname'])
    if len(declared_hostname) > 64:
        max_hostname = 63 - len(services['domainname'])
        services['hostname'] = services['hostname'][0:max_hostname]
    if dns_services:
        services['dns_services'] = dns_services
    else:
        services['dns_services'] = DEFAULT_DNS_SERVERS
    if ntp_services:
        services['ntp_services'] = ntp_services
    else:
        services['ntp_services'] = DEFAULT_NTP_SERVERS

    # f5-declarative-onboarding mgmt interface for 1 NIC
    if onenic and do_enabled:
        do_declaration['Common']['internal'] = {
            'class': 'VLAN',
            'mtu': m_mtu,
            'tag': 4094,
            'interfaces': [{
                'name': '1.0',
                'tagged': False
            }]
        }
        if len(m_nm) > 3:
            if tmos_onboard_utils.is_v4(m_ip):
                m_nm = tmos_onboard_utils.ipv4_cidr_from_netmask(m_nm)
            else:
                m_nm = '64'
        do_declaration['Common']['self_1nic'] = {
            'class': 'SelfIp',
            'address': "%s/%s" % (m_ip, m_nm),
            'vlan': 'internal',
            'allowService': 'default',
            'trafficGroup': 'traffic-group-local-only'
        }
        do_declaration['Common']['configsync'] = {
            'class': 'ConfigSync',
            'configsyncIp': m_ip
        }
        do_declaration['Common']['failoverAddress'] = {
            'class': 'FailoverUnicast',
            'address': m_ip
        }
        do_declaration['Common']['default'] = {
            'class': 'Route',
            'gw': m_gw,
            'network': 'default',
            'mtu': m_mtu
        }

    if do_enabled:
        # f5-declarative-onboarding for L2 networking
        for l_id in links:
            link = links[l_id]
            do_declaration['Common'][link['net_name']] = {
                'class':
                'VLAN',
                'mtu':
                link['mtu'],
                'tag':
                link['segmentation_id'],
                'interfaces': [{
                    'name': link['interface'],
                    'tagged': link['tagged']
                }]
            }
        # f5-declarative-onboarding for L3 interfaces
        for n_link in selfips:
            selfip = selfips[n_link]
            if len(selfip['netmask']) > 3:
                if tmos_onboard_utils.is_v4(
                        selfip['ip_address'].split('%')[0]):
                    selfip[
                        'netmask'] = tmos_onboard_utils.ipv4_cidr_from_netmask(
                            selfip['netmask'])
            do_declaration['Common'][selfip['selfip_name']] = {
                'class':
                'SelfIp',
                'address':
                "%s/%s" %
                (selfip['ip_address'].split('%')[0], selfip['netmask']),
                'vlan':
                selfip['net_name'],
                'allowService':
                'all',
                'trafficGroup':
                'traffic-group-local-only'
            }
        # f5-declarative-onboarding for L3 routes
        for n_link in routes:
            for route in routes[n_link]:
                if not (route['exclude'] or route['use_rd']):
                    if len(route['netmask']) > 3:
                        if tmos_onboard_utils.is_v4(
                                route['gateway'].split('%')[0]):
                            route[
                                'netmask'] = tmos_onboard_utils.ipv4_cidr_from_netmask(
                                    route['netmask'])
                    do_declaration['Common'][route['route_name']] = {
                        'class': 'Route',
                        'gw': route['gateway'],
                        'network':
                        "%s/%s" % (route['network'], route['netmask']),
                        'mtu': 0
                    }
                    if route['network'] == '0.0.0.0' or route[
                            'network'] == '::':
                        do_declaration['Common'][
                            route['route_name']]['network'] = 'default'
        # f5-declarative-onboarding for services
        do_declaration['Common']['hostname'] = "%s.%s" % (
            services['hostname'], services['domainname'])
        do_declaration['Common']['dnsServers'] = {
            'class': 'DNS',
            'nameServers': services['dns_services'],
            'search': [services['domainname']]
        }
        do_declaration['Common']['ntpServers'] = {
            'class': 'NTP',
            'servers': services['ntp_services'],
            'timezone': DEFAULT_TIMEZONE
        }
        # f5-declarative-onboarding for CMI
        for link in links:
            if links[link]['interface'] == configsync_interface:
                if link in selfips:
                    do_declaration['Common']['configsync'] = {
                        'class': 'ConfigSync',
                        'configsyncIp':
                        selfips[link]['ip_address'].split('%')[0]
                    }
                    do_declaration['Common']['failoverAddress'] = {
                        'class': 'FailoverUnicast',
                        'address': selfips[link]['ip_address'].split('%')[0]
                    }
    tmos_onboard_utils.start_tmm()
    return {
        'onenic': onenic,
        'mgmt_address': m_ip,
        'mgmt_netmask': m_nm,
        'mgmt_gateway': m_gw,
        'mgmt_mtu': m_mtu,
        'configsync_interface': configsync_interface,
        'default_route_interface': default_route_interface,
        'links': links,
        'selfips': selfips,
        'routes': routes,
        'services': services,
        'do_declaration': do_declaration
    }


def create_mgmt_init_script(resources):
    """Create initialization scripts for the mgmt interface"""
    LOG.debug('writing out pre declaration mgmt scripts')
    LOG.debug('mmgt ip %s/%s', resources['mgmt_address'],
              resources['mgmt_netmask'])
    if resources['mgmt_gateway']:
        LOG.debug('mmgt gw %s', resources['mgmt_gateway'])
    tmsh_cmd_dir_exists()
    mgmt_onboard_script = PRE_DO_TMSH_CMD_FILE_DIR + '/001_mgmt_setup.sh'
    # write out management network configuration
    with open(mgmt_onboard_script, 'w') as mgmt_script:
        mgmt_script.write("#!/bin/bash\n")
        mgmt_script.write("echo 'starting mgmt network provisioning'\n")
        mgmt_script.write(
            "tmsh modify sys global-settings mgmt-dhcp disabled\n")
        if resources['onenic']:
            mgmt_script.write("echo '1 NIC deployment discovered'\n")
            mgmt_script.write(
                "tmsh modify sys db provision.1nicautoconfig value disable\n")
            mgmt_script.write(
                "tmsh modify sys db provision.1nic value forced_enable\n")
            mgmt_script.write("tmsh modify sys httpd ssl-port 8443\n")
            mgmt_script.write(
                "tmsh modify net self-allow defaults add { tcp:8443 }\n")
            mgmt_script.write("sleep 5\n")
            mgmt_script.write(
                "tmsh create sys management-ip %s/%s\n" %
                (resources['mgmt_address'], resources['mgmt_netmask']))
            mgmt_script.write("tmsh list net vlan internal 2>/dev/null\n")
            mgmt_script.write("if [ \"$?\" == \"1\" ]; then \n")
            mgmt_script.write(
                "    tmsh create net vlan internal mtu %s interfaces replace-all-with { 1.0 } tag 4094\n"
                % resources['mgmt_mtu'])
            mgmt_script.write("else\n")
            mgmt_script.write(
                "    tmsh modify net vlan internal mtu %s interfaces replace-all-with { 1.0 } tag 4094\n"
                % resources['mgmt_mtu'])
            mgmt_script.write("fi\n")
            mgmt_script.write(
                "tmsh create net self self_1nic { address %s/%s allow-service default vlan internal }\n"
                % (resources['mgmt_address'], resources['mgmt_netmask']))
            if resources['mgmt_gateway']:
                mgmt_script.write(
                    "tmsh create sys management-route default gateway %s\n" %
                    resources['mgmt_gateway'])
                mgmt_script.write(
                    "tmsh create net route default network default gw %s\n" %
                    resources['mgmt_gateway'])
            mgmt_script.write("ip link set mgmt mtu %s\n" %
                              resources['mgmt_mtu'])
            mgmt_script.write("ip link set eth0 mtu %s\n" %
                              resources['mgmt_mtu'])
            mgmt_script.write(
                "echo 'ip link set mgmt mtu %s' >> /config/startup\n" %
                resources['mgmt_mtu'])
            mgmt_script.write(
                "echo 'ip link set eth0 mtu %s' >> /config/startup\n" %
                resources['mgmt_mtu'])
        else:
            mgmt_script.write("sleep 5\n")
            mgmt_script.write(
                "tmsh create sys management-ip %s/%s\n" %
                (resources['mgmt_address'], resources['mgmt_netmask']))
            if resources['mgmt_gateway']:
                mgmt_script.write(
                    "tmsh create sys management-route default gateway %s\n" %
                    resources['mgmt_gateway'])
            mgmt_script.write("ip link set mgmt mtu %s\n" %
                              resources['mgmt_mtu'])
            mgmt_script.write(
                "echo 'ip link set mgmt mtu %s' >> /config/startup\n" %
                resources['mgmt_mtu'])
        mgmt_script.write(
            "echo 'mgmt interface configured: %s/%s'\n" %
            (resources['mgmt_address'], resources['mgmt_netmask']))


def create_tmm_net_init_script(resources):
    """Create the initialization script for TMM network interfaces"""
    LOG.debug('writing out non declarative network provisioning scripts')
    network_onboard_script = NON_DO_TMSH_CMD_FILE_DIR + '/001_network_setup.sh'
    with open(network_onboard_script, 'w') as net_script:
        net_script.write("#!/bin/bash\n")
        net_script.write("echo 'starting network provisioning'\n")
        if resources['onenic']:
            net_script.write("echo '1 NIC deployment discovered'\n")
            net_script.write(
                "echo 'VLAN and SelfIP set with the management script'\n")
        # write out L2 network configuration
        for l_id in resources['links']:
            link = resources['links'][l_id]
            if not link['tagged']:
                net_script.write(
                    "tmsh create net vlan %s mtu %s interfaces replace-all-with { %s } tag %s\n"
                    % (link['net_name'], link['mtu'], link['interface'],
                       link['segmentation_id']))
            else:
                net_script.write(
                    "tmsh create net vlan %s mtu %s interfaces replace-all-with { %s { tagged } } tag %s\n"
                    % (link['net_name'], link['mtu'], link['interface'],
                       link['segmentation_id']))
            if link['route_domain'] > 0:
                net_script.write(
                    "tmsh create net route-domain %s { id %s vlans add { %s } }\n"
                    % (link['route_domain'], link['route_domain'],
                       link['net_name']))
        # write out L3 network configuration
        for n_link in resources['selfips']:
            selfip = resources['selfips'][n_link]
            net_script.write(
                "tmsh create net self %s address %s/%s vlan %s allow-service all\n"
                % (selfip['selfip_name'], selfip['ip_address'],
                   selfip['netmask'], selfip['net_name']))

        for n_link in resources['routes']:
            for route in resources['routes'][n_link]:
                if not route['exclude']:
                    net_script.write(
                        "tmsh create net route %s network %s/%s gw %s\n" %
                        (route['route_name'], route['network'],
                         route['netmask'], route['gateway']))
        net_script.write("echo 'networking configured'\n")


def create_services_init_script(resources):
    """Create the initialization script for services configurations"""
    LOG.debug('writing out services initialization script')
    services_onboard_script = PRE_DO_TMSH_CMD_FILE_DIR + '/002_services_setup.sh'
    if os.path.isfile(services_onboard_script):
        util.del_file(services_onboard_script)
    with open(services_onboard_script, 'w') as services_script:
        services = resources['services']
        services_script.write(
            "tmsh modify sys global-settings hostname %s.%s\n" %
            (services['hostname'], services['domainname']))
        services_script.write(
            "tmsh modify sys management-dhcp sys-mgmt-dhcp-config request-options delete { host-name }\n"
        )
        services_script.write(
            "tmsh modify sys dns search replace-all-with { %s }\n" %
            services['domainname'])
        services_script.write(
            "tmsh modify sys dns name-servers replace-all-with { %s }\n" %
            " ".join(services['dns_services']))
        services_script.write(
            "tmsh modify sys management-dhcp sys-mgmt-dhcp-config request-options delete { domain-name-servers domain-name }\n"
        )
        services_script.write("tmsh modify sys ntp timezone %s\n" %
                              DEFAULT_TIMEZONE)
        services_script.write(
            "tmsh modify sys ntp servers replace-all-with { %s }\n" %
            " ".join(services['ntp_services']))
        services_script.write(
            "tmsh modify sys management-dhcp sys-mgmt-dhcp-config request-options delete { ntp-servers }\n"
        )
        services_script.write("echo 'services configured'\n")


def create_cmi_init_script(resources):
    """Create the initialization script for CMI configurations"""
    # write out required CMI settings
    LOG.debug('writing out CMI initialization script')
    sync_onboard_script = NON_DO_TMSH_CMD_FILE_DIR + '/003_configsync_setup.sh'
    if os.path.isfile(sync_onboard_script):
        util.del_file(sync_onboard_script)
    with open(sync_onboard_script, 'w') as cmi_script:
        services = resources['services']
        cmi_script.write(
            "tmsh mv cm device $(tmsh list cm device | grep 'cm device' | cut -d ' ' -f3) %s\n"
            % services['hostname'])
        if resources['onenic']:
            cmi_script.write(
                "tmsh show net self self_1nic > /dev/null 2>&1; while [ $? -ne 0 ]; do sleep 2; tmsh show net self self_1nic > /dev/null 2>&1; done\n"
            )
            cmi_script.write(
                "tmsh modify /sys db configsync.allowmanagement value enable\n"
            )
            cmi_script.write(
                "tmsh modify cm device %s configsync-ip %s unicast-address { { effective-ip %s effective-port 1026 ip %s } }\n"
                % (services['hostname'], resources['mgmt_address'],
                   resources['mgmt_address'], resources['mgmt_address']))
        else:
            for link in resources['links']:
                if resources['links'][link]['interface'] == resources[
                        'configsync_interface']:
                    if link in resources['selfips']:
                        selfip = resources['selfips'][link]
                        sip = selfip['ip_address']
                        if not selfip['netmask']:
                            sip = selfip['ip_address'].split('/')[0]
                        cmi_script.write(
                            "tmsh show net self %s > /dev/null 2>&1; while [ $? -ne 0 ]; do sleep 2; tmsh show net self %s > /dev/null 2>&1; done\n"
                            % (selfip['selfip_name'], selfip['selfip_name']))
                        cmi_script.write(
                            "tmsh modify cm device %s configsync-ip %s unicast-address { { effective-ip %s effective-port 1026 ip %s } { effective-ip management-ip effective-port 1026 ip management-ip } } mirror-ip %s\n"
                            % (services['hostname'], sip, sip, sip, sip))
                    else:
                        LOG.warn('configsync configuration incomplete')
            cmi_script.write("echo 'CMI configsync interface configured'\n")
        return resources


def create_post_onboard_script(post_onboard_commands):
    """Create the post onboard command script"""
    if post_onboard_commands:
        post_onboard_commands_script = POST_ONBOARD_CMD_FILE_DIR + \
            '/001_post_onboard_commands.sh'
        if os.path.isfile(post_onboard_commands_script):
            util.del_file(post_onboard_commands_script)
        with open(post_onboard_commands_script, 'w') as pob_script:
            pob_script.write("#!/bin/bash\n")
            pob_script.write(
                "echo 'starting post onboarding commands provisioning'\n\n")
            pob_script.write("cmds=(\n")
            for cmd in post_onboard_commands:
                pob_script.write("\"%s\"\n" % cmd.replace('"', r'\"'))
            pob_script.write(")\n\n")
            pob_script.write("for (( i = 0; i < ${#cmds[@]} ; i++ )); do\n")
            pob_script.write("    echo \"Running: ${cmds[$i]}\"\n")
            pob_script.write("    eval \"${cmds[$i]}\"\n")
            pob_script.write("    if [ $? -eq 1 ]; then\n")
            pob_script.write(
                "        echo \"Command: ${cmds[$i]} Failed. Stopping execution of any further commands.\"\n"
            )
            pob_script.write("        exit 1\n")
            pob_script.write("    fi\n")
            pob_script.write("done\n\n")


def create_onboard_artifacts(resources,
                             do_enabled=True,
                             do_additional_declarations=None,
                             do_additional_declarations_url=None,
                             do_template_variables=None,
                             ts_declaration=None,
                             ts_declaration_url=None,
                             ts_template_variables=None,
                             as3_declaration=None,
                             as3_declaration_url=None,
                             as3_template_variables=None,
                             post_onboard_commands=None):
    """Generates all needed onboarding artifacts from metadata or the environment"""
    create_mgmt_init_script(resources)
    create_tmm_net_init_script(resources)
    create_services_init_script(resources)
    create_cmi_init_script(resources)
    create_post_onboard_script(post_onboard_commands)
    if do_enabled:
        tmos_onboard_utils.persist_do_declaration(
            resources['do_declaration'],
            do_additional_declarations,
            do_additional_declarations_url,
            do_template_variables)
    if ts_declaration:
        try:
            tmos_onboard_utils.persist_ts_declaration(ts_declaration)
        except Exception as err:
            LOG.error('exception persisting TS declaration: %s', err)
    if ts_declaration_url:
        try:
            tmos_onboard_utils.download_ts_declaration(ts_declaration_url, ts_template_variables)
        except Exception as err:
            LOG.error('exception downloading TS declaration: %s', err)
    if as3_declaration:
        try:
            tmos_onboard_utils.persist_as3_declaration(as3_declaration)
        except Exception as err:
            LOG.error('exception persisting AS3 declaration: %s', err)
    if as3_declaration_url:
        try:
            tmos_onboard_utils.download_as3_declaration(as3_declaration_url, as3_template_variables)
        except Exception as err:
            LOG.error('exception downloading AS3 declaration: %s', err)


def create_pre_do_onboard():
    """Creates the initialization script for all pre f5-declarative-onboarding tasks"""
    LOG.debug('writing out pre declaration onboard initialization script')
    onboard_script = PRE_DO_TMSH_CMD_FILE_DIR + '/onboard.sh'
    if os.path.isfile(onboard_script):
        util.del_file(onboard_script)
    script_files = os.listdir(PRE_DO_TMSH_CMD_FILE_DIR)
    script_files.sort()
    with open(onboard_script, 'w') as obs:
        obs.write("#!/bin/bash\n\n")
        obs.write("function check_mcpd_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        if tmsh -a show sys mcp-state field-fmt 2> /dev/null | grep -q running; then\n"
        )
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for mcpd to reach running state'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function check_icontrol_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        started=$(curl -su 'admin:' http://localhost:8100/shared/echo | grep '\"stage\":\"STARTED\"' | wc -l 2>/dev/null)\n"
        )
        obs.write("        if [ $started == 1 ]; then\n")
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for iControl to start'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function exec_phases() {\n")
        for script_file in script_files:
            obs.write("    /bin/bash %s/%s\n" %
                      (PRE_DO_TMSH_CMD_FILE_DIR, script_file))
        obs.write("    echo 1 > " + PRE_DO_ONBOARD_COMPLETE_FLAG_FILE + '\n')
        obs.write("}\n\n")
        obs.write("check_mcpd_up\n")
        obs.write("exec_phases\n")
        obs.write("tmsh save sys config\n")
        obs.write("check_mcpd_up\n")
        obs.write("check_icontrol_up\n")
    os.chmod(onboard_script, 0775)


def create_non_do_onboard():
    """Creates the initialization script for all tasks when not using f5-declarative-onboarding"""
    LOG.debug('writing out non declared onboard initialization script')
    onboard_script = NON_DO_TMSH_CMD_FILE_DIR + '/onboard.sh'
    if os.path.isfile(onboard_script):
        util.del_file(onboard_script)
    script_files = os.listdir(NON_DO_TMSH_CMD_FILE_DIR)
    script_files.sort()
    with open(onboard_script, 'w') as obs:
        obs.write("#!/bin/bash\n\n")
        obs.write("function check_mcpd_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        if tmsh -a show sys mcp-state field-fmt 2> /dev/null | grep -q running; then\n"
        )
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for mcpd to reach running state'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function check_icontrol_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        started=$(curl -su 'admin:' http://localhost:8100/shared/echo | grep '\"stage\":\"STARTED\"' | wc -l 2>/dev/null)\n"
        )
        obs.write("        if [ $started == 1 ]; then\n")
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for iControl to start'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function exec_phases() {\n")
        for script_file in script_files:
            obs.write("    /bin/bash %s/%s\n" %
                      (NON_DO_TMSH_CMD_FILE_DIR, script_file))
        obs.write("    echo 1 > " + NON_DO_ONBOARD_COMPLETE_FLAG_FILE + '\n')
        obs.write("}\n\n")
        obs.write("check_mcpd_up\n")
        obs.write("exec_phases\n")
        obs.write("tmsh save sys config\n")
        obs.write("check_mcpd_up\n")
        obs.write("check_icontrol_up\n")
    os.chmod(onboard_script, 0775)


def create_tg_actions(tgactive_url, tgstandby_url, tgrefresh_url):
    """adds action scripts to call webhooks if defined"""
    if tgactive_url:
        inject_tg_action_script('active')
    if tgstandby_url:
        inject_tg_action_script('standby')
    if tgrefresh_url:
        inject_tg_action_script('refresh')


def create_post_onboard():
    """Creates the initialization script for all post onboarding scripts"""
    LOG.debug('writing out post onboard initialization script')
    onboard_script = POST_ONBOARD_CMD_FILE_DIR + '/onboard.sh'
    if os.path.isfile(onboard_script):
        util.del_file(onboard_script)
    script_files = os.listdir(POST_ONBOARD_CMD_FILE_DIR)
    script_files.sort()
    with open(onboard_script, 'w') as obs:
        obs.write("#!/bin/bash\n\n")
        obs.write("function check_mcpd_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        if tmsh -a show sys mcp-state field-fmt 2> /dev/null | grep -q running; then\n"
        )
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for mcpd to reach running state'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function check_icontrol_up() {\n")
        obs.write("    checks=0\n")
        obs.write("    while [ $checks -lt 120 ]; do\n")
        obs.write(
            "        started=$(curl -su 'admin:' http://localhost:8100/shared/echo | grep '\"stage\":\"STARTED\"' | wc -l 2>/dev/null)\n"
        )
        obs.write("        if [ $started == 1 ]; then\n")
        obs.write("            break\n")
        obs.write("        fi\n")
        obs.write("        echo 'waiting for iControl to start'\n")
        obs.write("        let checks=checks+1\n")
        obs.write("        sleep 10\n")
        obs.write("    done\n")
        obs.write("}\n\n")
        obs.write("function exec_phases() {\n")
        for script_file in script_files:
            obs.write("    /bin/bash %s/%s\n" %
                      (POST_ONBOARD_CMD_FILE_DIR, script_file))
        obs.write("    echo 1 > " + POST_ONBOARD_FLAG_FILE + '\n')
        obs.write("}\n\n")
        obs.write("check_mcpd_up\n")
        obs.write("check_icontrol_up\n")
        obs.write("exec_phases\n")
    os.chmod(onboard_script, 0775)


def is_tg_action_injected(action, script_name):
    """ check if script is injected into /config/startup """
    injected_already = subprocess.Popen(
        "cat /config/failover/tg%s | grep %s | wc -l" % (action, script_name),
        stdout=subprocess.PIPE,
        shell=True).communicate()[0].replace('\n', '')
    if injected_already == '0':
        return False
    return True


def inject_tg_action_script(action):
    """ insert script to run on tg state change action """
    notify_script_name = "%s/%s" % (os.path.dirname(
        os.path.realpath(__file__)), TG_NOTIFY_SCRIPT)
    if not is_tg_action_injected(action, notify_script_name):
        LOG.info('injecting tg action script %s into /config/failover/tg%s',
                 notify_script_name, action)
        with open('/config/failover/tg%s' % action, 'a+') as tgas:
            tgas.write("/usr/bin/env python %s %s ${1} %s\n" %
                       (notify_script_name, MODULE_NAME, action))


def is_startup_injected(script_name):
    """ check if script is injected into /config/startup """
    injected_already = subprocess.Popen(
        "cat /config/startup | grep " + script_name + " | wc -l",
        stdout=subprocess.PIPE,
        shell=True).communicate()[0].replace('\n', '')
    if injected_already == '0':
        return False
    return True


def run_do_wait():
    """ run do wait script """
    deploy_script_name = "%s/%s" % (os.path.dirname(
        os.path.realpath(__file__)), DO_DELAYED_DEPLOYMENT_SCRIPT)
    if not is_startup_injected(DO_DELAYED_DEPLOYMENT_SCRIPT):
        LOG.info(
            'injecting f5-declarative-onboard wait script %s into /config/startup',
            deploy_script_name)
        with open('/config/startup', 'a+') as css:
            css.write("/usr/bin/env python %s %s &\n" %
                      (deploy_script_name, MODULE_NAME))
    LOG.info('running f5-declarative-onboard wait script %s',
             deploy_script_name)
    subprocess.call(
        ['/usr/bin/env', 'python', deploy_script_name, MODULE_NAME, '&'])


def run_declarations_deffered():
    """ run AS3 deferred deployment script """
    deploy_script_name = "%s/%s" % (os.path.dirname(
        os.path.realpath(__file__)), DELAYED_DECLARATION_SCRIPT)
    if not is_startup_injected(DELAYED_DECLARATION_SCRIPT):
        LOG.info(
            'injecting declarations delayed deployment script %s into /config/startup',
            deploy_script_name)
        with open('/config/startup', 'a+') as css:
            css.write("/usr/bin/env python %s %s &\n" %
                      (deploy_script_name, MODULE_NAME))
    LOG.info('running declarations delayed deployment script %s',
             deploy_script_name)
    subprocess.call(
        ['/usr/bin/env', 'python', deploy_script_name, MODULE_NAME, '&'])


def run_post_onboard_commands():
    """ run post onboard commands """
    post_onboard_script = POST_ONBOARD_CMD_FILE_DIR + '/onboard.sh'
    with open(LOG_FILE, 'a+') as onboardlog:
        LOG.info('running post onboard script')
        subprocess.call(['nohup', 'sh', '-c', post_onboard_script, '&'],
                        stdout=onboardlog,
                        stderr=onboardlog)
        end_time = time.time() + ONBOARD_TIMEOUT
        while (end_time - time.time()) > 0:
            if not os.path.exists(POST_ONBOARD_FLAG_FILE):
                time.sleep(1)
            else:
                end_time = 0
        if os.path.exists(POST_ONBOARD_FLAG_FILE):
            LOG.error('post onboard commands did not complete properly')
            return False
        return True


def onboard(trusted_sources, icontrollx_package_urls, do_enabled, ts_enabled,
            as3_enabled, post_onboard_enabled, phone_home_url,
            phone_home_url_verify_tls, phone_home_url_metadata,
            phone_home_cli):
    """Implements the onboarding business logic"""
    # initialize pre declarative onboarding tasks
    pre_do_onboard_script = PRE_DO_TMSH_CMD_FILE_DIR + '/onboard.sh'
    with open(LOG_FILE, 'a+') as onboardlog:
        LOG.info('running pre declared onboarding scripts')
        subprocess.call(['nohup', 'sh', '-c', pre_do_onboard_script, '&'],
                        stdout=onboardlog,
                        stderr=onboardlog)
    end_time = time.time() + ONBOARD_TIMEOUT
    while (end_time - time.time()) > 0:
        if not os.path.exists(PRE_DO_ONBOARD_COMPLETE_FLAG_FILE):
            time.sleep(1)
        else:
            end_time = 0

    if os.path.exists(PRE_DO_ONBOARD_COMPLETE_FLAG_FILE):
        # download referenced extensions
        for ext_url in icontrollx_package_urls:
            LOG.info('downloading: %s', ext_url)
            if tmos_onboard_utils.download_extension(ext_url):
                LOG.info(
                    'extension %s downloaded in discovered iControl extensions',
                    ext_url)
            else:
                LOG.error('exenstion %s could not be donwloaded', ext_url)

        LOG.debug('installing discovered iControlLX extensions')
        tmos_onboard_utils.install_extensions(trusted_sources)

        # fix restjavad hang with 1NIC deployments
        tmos_onboard_utils.bigstart_restart('restjavad')

        # use f5-declarative-onboarding if not disabled and it is available
        non_do_onboard = False
        do_posted = False

        if do_enabled:
            LOG.debug('waiting for iControl LX interfaces to be available')
            icontrol_available = False
            for _ in range(5):
                if tmos_onboard_utils.wait_for_icontrollx(timeout=30):
                    icontrol_available = True
                    break
                time.sleep(1)
            if icontrol_available:
                LOG.debug(
                    'waiting for f5-declarative-onboarding to become available'
                )
                do_available = False
                for _ in range(5):
                    if tmos_onboard_utils.wait_for_rest_worker(
                            '/mgmt/shared/declarative-onboarding', timeout=30):
                        do_available = True
                        break
                    time.sleep(1)
                if do_available:
                    if not tmos_onboard_utils.do_declare():
                        LOG.error(
                            'f5-declarative-onboarding initial post failed, reverting to tmsh based onboarding'
                        )
                        non_do_onboard = True
                    else:
                        if not as3_enabled:
                            run_do_wait()
                            return
                        else:
                            do_posted = True
                else:
                    LOG.error(
                        'f5-declarative-onboarding never became available.. timeout...'
                    )
                    LOG.error(
                        'check /var/log/restnoded/restnoded.log for errors')
                    non_do_onboard = True
            else:
                LOG.error('iControl LX never became available.. timeout...')
                LOG.error('check /var/log/restnoded/restnoded.log for errors')
                non_do_onboard = True
        else:
            non_do_onboard = True

        if non_do_onboard:
            non_do_onboard_script = NON_DO_TMSH_CMD_FILE_DIR + '/onboard.sh'
            with open(LOG_FILE, 'a+') as onboardlog:
                LOG.info('running non declarative onboarding script')
                subprocess.call(
                    ['nohup', 'sh', '-c', non_do_onboard_script, '&'],
                    stdout=onboardlog,
                    stderr=onboardlog)
            end_time = time.time() + ONBOARD_TIMEOUT
            while (end_time - time.time()) > 0:
                if not os.path.exists(NON_DO_ONBOARD_COMPLETE_FLAG_FILE):
                    time.sleep(1)
                else:
                    end_time = 0

        onboard_status = SUCCESS

        if do_posted or os.path.exists(NON_DO_ONBOARD_COMPLETE_FLAG_FILE):
            if ts_enabled or as3_enabled:
                if non_do_onboard:

                    # reset restnoded to over come AS3 issue
                    # https://github.com/F5Networks/f5-appsvcs-extension/issues/108
                    tmos_onboard_utils.bigstart_restart('restnoded')
                    tmos_onboard_utils.wait_for_icontrollx()

                    if ts_enabled and (not onboard_status == ERROR):
                        ts_available = False
                        for _ in range(5):
                            if tmos_onboard_utils.wait_for_rest_worker(
                                    '/mgmt/shared/telemetry/declare',
                                    timeout=30):
                                ts_available = True
                            break
                        time.sleep(1)

                        if ts_available:
                            # check if there was a previous declaration.. if so don't issue
                            response = tmos_onboard_utils.get_ts_declaration()
                            # we have to check the format of the reponse because TS
                            # does not assure the response is valid JSON
                            if hasattr(response, 'status_code'):
                                if response.status_code == 204 or response.status_code == 200:
                                    LOG.info(
                                        'making initial f5-telemetry-streaming declaration'
                                    )
                                    ts_declared = tmos_onboard_utils.ts_declare(
                                    )
                                    if not ts_declared:
                                        LOG.error(
                                            'f5-telemetry-streaming inital declaration failed'
                                        )
                                        onboard_status = ERROR
                                    else:
                                        LOG.info(
                                            'f5-telemetry-streaming initial declaration submitted successfully'
                                        )
                                else:
                                    LOG.warn(
                                        'f5-telemetry-streaming has a previously errored declaration, not deploying'
                                    )
                                    onboard_status = ERROR
                            else:
                                LOG.error(
                                    'f5-telemetry-streaming has failed, not deploying initial declaration declaration %s - %s',
                                    response.status_code, response.text)
                                onboard_status = ERROR
                        else:
                            LOG.error(
                                'f5-telemetry never became available.. timeout...'
                            )
                            LOG.error(
                                'check /var/log/restnoded/restnoded.log for errors'
                            )
                            onboard_status = ERROR

                    if as3_enabled and (not onboard_status == ERROR):
                        as3_available = False
                        for _ in range(5):
                            if tmos_onboard_utils.wait_for_rest_worker(
                                    '/mgmt/shared/appsvcs/declare',
                                    timeout=30):
                                as3_available = True
                                break
                            time.sleep(1)

                        if as3_available:
                            # check if there was a previous declaration.. if so don't issue
                            response = tmos_onboard_utils.get_as3_declaration()
                            # we have to check the format of the reponse because AS3
                            # does not assure the response is valid JSON
                            if hasattr(response, 'status_code'):
                                if response.status_code == 204 or response.status_code == 200:
                                    LOG.info(
                                        'making initial f5-appsvcs-extension declaration'
                                    )
                                    as3_declared = tmos_onboard_utils.as3_declare(
                                    )
                                    if not as3_declared:
                                        LOG.error(
                                            'f5-appsvcs-extension inital declaration failed'
                                        )
                                        onboard_status = ERROR
                                    else:
                                        LOG.info(
                                            'f5-appsvcs-extension initial declaration submitted successfully'
                                        )
                                        if post_onboard_enabled:
                                            if not run_post_onboard_commands:
                                                onboard_status = ERROR
                                else:
                                    LOG.warn(
                                        'f5-appsvcs-extension has a previously errored declaration, not deploying'
                                    )
                                    onboard_status = ERROR
                            else:
                                LOG.error(
                                    'f5-appsvcs-extension has failed, not deploying initial declaration declaration %s - %s',
                                    response.status_code, response.text)
                                onboard_status = ERROR
                        else:
                            LOG.error(
                                'f5-appsvcs-extension never became available.. timeout...'
                            )
                            LOG.error(
                                'check /var/log/restnoded/restnoded.log for errors'
                            )
                            onboard_status = ERROR
                else:
                    run_declarations_deffered()
                    return
            elif post_onboard_enabled:
                if not run_post_onboard_commands():
                    onboard_status = ERROR
        else:
            onboard_status = ERROR
            LOG.error(
                'neither f5-declarative-onboarding posting or non declarative scripts completed'
            )
    else:
        onboard_status = ERROR
        LOG.error('pre declarative configuration did not complete')

    if phone_home_url:
        tmos_onboard_utils.phone_home(phone_home_url, do_enabled, ts_enabled,
                                      as3_enabled, onboard_status,
                                      phone_home_url_verify_tls,
                                      phone_home_url_metadata)
    if phone_home_cli and onboard_status == SUCCESS:
        tmos_onboard_utils.run_cmd(phone_home_cli)
    LOG.info('onboarding ended with status: %s', onboard_status)


def clean():
    """Remove any onboarding artifacts"""
    tmos_onboard_utils.clean()


def handle(name, cloud_config, cloud, log, args):
    """Cloud-init processing function"""
    tag = MODULE_NAME
    enabled = False
    if tag in cloud_config:
        try:
            enabled = bool(cloud_config[tag]['enabled'])
        except Exception:
            LOG.error("%s missing enabled attribute", tag)
            return
    if enabled:
        keys = []
        if "ssh_authorized_keys" in cloud_config:
            cfgkeys = cloud_config["ssh_authorized_keys"]
            keys.extend(cfgkeys)
        rd_enabled = True
        if 'rd_enabled' in cloud_config[tag]:
            rd_enabled = bool(cloud_config[tag]['rd_enabled'])
        default_route_interface = None
        if 'default_route_interface' in cloud_config[tag]:
            default_route_interface = str(
                cloud_config[tag]['default_route_interface'])
        configsync_interface = None
        if 'configsync_interface' in cloud_config[tag]:
            configsync_interface = str(
                cloud_config[tag]['configsync_interface'])
        dhcp_timeout = 120
        if 'dhcp_timeout' in cloud_config[tag]:
            dhcp_timeout = int(cloud_config[tag]['dhcp_timeout'])
        inject_routes = True
        if 'inject_routes' in cloud_config[tag]:
            inject_routes = bool(cloud_config[tag]['inject_routes'])
        icontrollx_trusted_sources = True
        if 'icontrollx_trusted_sources' in cloud_config[tag]:
            icontrollx_trusted_sources = cloud_config[tag][
                'icontrollx_trusted_sources']
        icontrollx_package_urls = []
        if 'icontrollx_package_urls' in cloud_config[tag]:
            icontrollx_package_urls = cloud_config[tag][
                'icontrollx_package_urls']
        do_enabled = True
        if 'do_enabled' in cloud_config[tag]:
            do_enabled = bool(cloud_config[tag]['do_enabled'])
        do_additional_declarations = None
        do_additional_declarations_url = None
        do_template_variables = None
        if 'do_declaration' in cloud_config[tag]:
            do_additional_declarations = cloud_config[tag]['do_declaration']
        else:
            do_additional_declarations = False
        if 'do_declaration_url' in cloud_config[tag]:
            do_additional_declarations_url = cloud_config[tag][
                'do_declaration_url']
        if 'do_template_variables' in cloud_config[tag]:
            do_template_variables = cloud_config[tag]['do_template_variables']
        ts_enabled = True
        if 'ts_enabled' in cloud_config[tag]:
            ts_enabled = bool(cloud_config[tag]['ts_enabled'])
        ts_declaration = None
        ts_declaration_url = None
        ts_template_variables = None
        if 'ts_declaration' in cloud_config[tag]:
            ts_declaration = cloud_config[tag]['ts_declaration']
        if 'ts_declaration_url' in cloud_config[tag]:
            ts_declaration_url = cloud_config[tag]['ts_declaration_url']
        if 'ts_template_variables' in cloud_config[tag]:
            ts_template_variables = cloud_config[tag]['ts_template_variables']
        as3_enabled = True
        if 'as3_enabled' in cloud_config[tag]:
            as3_enabled = bool(cloud_config[tag]['as3_enabled'])
        as3_declaration = None
        as3_declaration_url = None
        as3_template_variables = None
        if 'as3_declaration' in cloud_config[tag]:
            as3_declaration = cloud_config[tag]['as3_declaration']
        if 'as3_declaration_url' in cloud_config[tag]:
            as3_declaration_url = cloud_config[tag]['as3_declaration_url']
        if 'as3_template_variables' in cloud_config[tag]:
            as3_template_variables = cloud_config[tag]['as3_template_variables']
        dhcpv4_options = None
        if 'dhcpv4_options' in cloud_config[tag]:
            dhcpv4_options = cloud_config[tag]['dhcpv4_options']
        post_onboard_enabled = False
        if 'post_onboard_enabled' in cloud_config[tag]:
            post_onboard_enabled = bool(
                cloud_config[tag]['post_onboard_enabled'])
        post_onboard_commands = []
        if 'post_onboard_commands' in cloud_config[tag]:
            post_onboard_commands = cloud_config[tag]['post_onboard_commands']
        tgactive_url = None
        if 'tgactive_url' in cloud_config[tag]:
            tgactive_url = cloud_config[tag]['tgactive_url']
        tgstandby_url = None
        if 'tgstandby_url' in cloud_config[tag]:
            tgstandby_url = cloud_config[tag]['tgstandby_url']
        tgrefresh_url = None
        if 'tgrefresh_url' in cloud_config[tag]:
            tgrefresh_url = cloud_config[tag]['tgrefresh_url']

        inject_public_ssh_keys(log, keys)
        resources = resolve_resources(rd_enabled, default_route_interface,
                                      configsync_interface, inject_routes,
                                      do_enabled, dhcp_timeout, dhcpv4_options)
        LOG.debug('resolved config resources: %s', resources)
        LOG.debug('do_enable: %s as3_enabled: %s ts_enabled: %s', do_enabled,
                  as3_enabled, ts_enabled)
        create_onboard_artifacts(resources,
                                 do_enabled,
                                 do_additional_declarations,
                                 do_additional_declarations_url,
                                 do_template_variables,
                                 ts_declaration,
                                 ts_declaration_url,
                                 ts_template_variables,
                                 as3_declaration,
                                 as3_declaration_url,
                                 as3_template_variables,
                                 post_onboard_commands)
        create_pre_do_onboard()
        create_non_do_onboard()
        create_post_onboard()
        create_tg_actions(tgactive_url, tgstandby_url, tgrefresh_url)

        phone_home_url = None
        if 'phone_home_url' in cloud_config[tag]:
            phone_home_url = cloud_config[tag]['phone_home_url']

        phone_home_url_verify_tls = True
        if 'phone_home_url_verify_tls' in cloud_config[tag]:
            phone_home_url_verify_tls = cloud_config[tag][
                'phone_home_url_verify_tls']

        phone_home_url_metadata = {}
        if 'phone_home_url_metadata' in cloud_config[tag]:
            phone_home_url_metadata = cloud_config[tag][
                'phone_home_url_metadata']

        phone_home_cli = None
        if 'phone_home_cli' in cloud_config[tag]:
            phone_home_cli = cloud_config[tag]['phone_home_cli']

        try:
            onboard(icontrollx_trusted_sources, icontrollx_package_urls,
                    do_enabled, ts_enabled, as3_enabled, post_onboard_enabled,
                    phone_home_url, phone_home_url_verify_tls,
                    phone_home_url_metadata, phone_home_cli)
        except Exception as err:
            LOG.error("onboard exception - %s", err)
        try:
            tmos_onboard_utils.clean()
        except Exception as err:
            LOG.error('onboard cleanup exception - %s', err)


if __name__ == "__main__":
    # Running the cloud-init module from the CLI python interpreter
    CLOUD_CONFIG_FILE = '/opt/cloud/instance/cloud-config.txt'
    CLOUD_CONFIG = {MODULE_NAME: {'enabled': True}}
    if os.path.exists(CLOUD_CONFIG_FILE):
        CLOUD_CONFIG = util.read_conf(CLOUD_CONFIG_FILE)
    handle(MODULE_NAME, CLOUD_CONFIG, None, logging, [])
